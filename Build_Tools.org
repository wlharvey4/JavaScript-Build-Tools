# -*- mode:org -*-

#+title:JavaScript Build Tools
#+date:2019-08-22 23:33
#+macro: version Version 0.0.8

* Babel
** Description
{{{heading(Babel is a JavaScript compiler)}}}

#+cindex:Babel
#+cindex:ECMAScript 2015
Babel is a toolchain that is mainly used to convert ECMAScript 2015+ code into
a backwards compatible version of JavaScript in current and older browsers or
environments.

Here are the main things Babel can do for you:

- Transform syntax

- Polyfill features that are missing in your target environment (through
  =@babel/polyfill=)

* WebPack
- [[https://webpack.js.org][WebPack Home]]


{{{heading(Webpack Concepts)}}}

#+cindex:bundler
#+cindex:module bundler
#+cindex:dependency graph
{{{command(webpack)}}} is a static module bundler for modern JavaScript
applications.  When {{{command(webpack)}}} processes your application, it
internally builds a *dependency graph* which maps every module your project
needs and generates one or more bundles.  Since version 4.0.0,
{{{command(webpack)}}} does not require a configuration file to bundle your
project.

** WebPack Core Concepts
#+cindex:core concepts
To get started you only need to understand its Core Concepts:

*** Entry
#+cindex:entry point
#+cindex:default entry point
#+cindex:@code{entry} property
#+cindex:configuration
#+cindex:dependency graph
- Entry point ::

                 An entry point indicates which module {{{command(webpack)}}}
                 should use to begin building out its internal dependency
                 graph.  {{{command(webpack)}}} will figure out which other
                 modules and libraries that entry point depends on (directly
                 and indirectly).

                 The default entry point value is ~./src/index.js~.

                 You can specify a different (or multiple entry points) by
                 configuring the =entry= property in the webpack configuration.

                 #+caption:Entry Point in webpack.config.js
                 #+name:entry-webpack-config
                 #+begin_src js
                 module.exports = {
                     entry: './path/to/my/entry/file.js'
                 }
                 #+end_src

*** Output

#+cindex:@code{output} property
#+cindex:emit
#+cindex:default output path
#+cindex:main output file
- Output property ::

     The =output= property tells {{{command(webpack)}}} where to emit the
     bundles it creates and how to name these files.

     The default output path for the main output file is ~./dist/main.js~, and
     the ~./dist~ folder for any other generate files.

     You can configure this part of the process by specifying an =output= field
     in your configuration:

     #+caption:Main Output File
     #+name:main-output-webpack-config
     #+begin_src js
     const path = require('path');

     module.exports = {
       entry: './path/to/my/entry/file.js',
       output: {
         path: path.resolve(__dirname, 'dist'),
         filename: 'my-first-webpack.bundle.js'
       }
     };
     #+end_src

     #+cindex:bundle name
     #+cindex:bundle path
     We use the ~output.filename~ and the ~output.path~ properties to tell
     {{{command(webpack)}}} the name of our bundle and where we want it to be
     emitted to.

     #+cindex:@code{path} module
     #+cindex:Node.js module, @code{path}
     The ~path~ module being imported at the top is a core Node.js module that
     gets used to manipulate file paths.

     #+attr_texinfo: :options Path resolve ([...paths])
     #+begin_defmethod
     - ...paths :: <string> a sequence of paths or path segments

     - __dirname :: <string> from Node.js Module, ~__dirname~ is the directory
                    name of the current module.  This is the same as the
                    ~path.dirname(__filename)~.

     - Returns :: <string> absolute path


     The ~path.resolve()~ method resolves a sequence of paths or path segments
     into an absolute path.  The given sequence of paths is processed from
     right to left, with each subsequent path prepended until an absolute path
     is constructed.  If after processing all given path segments an absolute
     path has not yet been generated, the current working directory is used.
     The resulting path is normalized and trailing slashes are removed unless
     the path is resolved to the root directory.  If no path segments are
     passed, ~path.resolve()~ will return the absolute path of the current
     working directory.
     #+end_defmethod

*** Loaders
#+cindex:JSON
#+cindex:JavaScript
{{{command(webpack)}}} only understands JavaScript and JSON files.

- Loaders ::

             #+cindex:dependency graph
             /Loaders/ allow {{{command(webpack)}}} to process other types of
             files and convert them into valid modules that can be consumed by
             your application and added to the dependency graph.

             #+cindex:dependency graph
             The ability to import any type of module, e.g. ~.css~ files, is a
             feature specific to {{{command(webpack)}}} and may not be
             supported by other bundlers or task runners.  We feel this
             extension of the language is warranted as it allows developers to
             build a more accurate dependency graph.


At a high level, loaders have two properties in your webpack configuration:

- =test= property ::

     The =test= property identifies which file or files should be transformed.

- =use= property ::

     The =use= property indicates which loader should be used to do the
                    transforming.


#+caption:webpack.config.js with Module Loaders
#+name:webpack-config-with-loaders
#+begin_src js
const path = require('path');

module.exports = {
  output: {
    filename: 'my-first-webpack.bundle.js'
  },
  module: {
    rules: [
      { test: /\.txt$/,
        use: 'raw-loader'
      }
    ]
  }
};
#+end_src

The configuration above has defined a =rules= property for a single module with
two required properties: =test= and =use=.  This tells webpack's compiler the
following:

#+begin_quote
"webpack compiler, when you come across a path that resolves to a '.txt' file
inside of a ~require()/import~ statement, use the ~raw~ -loader to transform it
before you add it to the bundle."
#+end_quote

#+cindex:rules, define
#+cindex:define rules
#+cindex:@code{module.rules}
When defining rules in your ~webpack.config.js~ file, you are defining them
under =module.rules= and not =rules=.  For your benefit, {{{command(webpack)}}}
will warn you if this is done incorrectly.

#+cindex:@code{regex}
When Using ~regex~ to match files, you may not quote it; i.e ~/\.txt$/~ is not
the same as '/\.txt$/' or "/\.txt$/".  The former instructs
{{{command(webpack)}}} to match any file that ends with ~.txt~ and the latter
instructs {{{command(webpack)}}} to match a single file with an absolute path
'.txt'; this is likely not your intention.

*** Plugins
#+cindex:plugin
While loaders are used to transform certain types of modules, /plugins/ can be
leveraged to perform a wider range of tasks like:

- bundle optimization,
- asset management and
- injection of environment variables


#+cindex:plugins list
See [[https://webpack.js.org/plugins][list of plugins]] for many available plugins.

{{{heading(Using Plugins)}}}

In order to use a plugin, you need to ~require()~ it and add it to the
=plugins= array.  Most plugins are customizable through options.  Since you can
use a plugin multiple times in a config for different purposes, you need to
create an instance of it by calling it with the ~new~ operator.

#+caption:webpack.config.js Demonstrating plugins
#+name:webpack-config-demonstrating-plugins
#+begin_src js
const HtmlWebpackPlugin = require('html-webpack-plugin'); //installed via npm
const webpack = require('webpack'); //to access built-in plugins

module.exports = {
  module: {
    rules: [
      { test: /\.txt$/, use: 'raw-loader' }
    ]
  },
  plugins: [
    new HtmlWebpackPlugin({template: './src/index.html'})
  ]
};
#+end_src

#+cindex:HTML file
#+cindex:HTML plugin
#+cindex:plugin, HTML
In the example above, the ~html-webpack-plugin~ generates an HTML file for your
application by injecting automatically all your generated bundles.

*** Mode
By setting the mode parameter to either:

- =development=
- =production= (default)
- =none=


{{{noindent}}}you can enable webpack's built-in optimizations that correspond
to each environment.  The default value is =production=.

#+caption:webpack.config.js Demonstrating Mode
#+name:webpack-config-demonstrating-mode
#+begin_src js
module.exports = {
  mode: 'production'
};
#+end_src

*** Browser Compatibility
#+cindex:browsers
#+cindex:ES5-compliant
#+cindex:IE8
#+cindex:@file{Promise}
#+cindex:@code{import()}
#+cindex:@code{reqeuire.ensure()}
#+cindex:polyfill
{{{command(webpack)}}} supports all browsers that are ES5-compliant (IE8 and
below are not supported).  {{{command(webpack)}}} needs ~Promise~ for
~import()~ and ~require.ensure()~.  If you want to support older browsers, you
will need to load a polyfill before using these expressions.

** Entry Points
#+cindex:@code{entry} property
#+cindex:configuration, entry
 There are multiple ways to define the =entry= property in your webpack
 configuration.

*** Single Entry Shorthand Syntax
#+cindex:single entry syntax
#+cindex:syntax, single entry
This is a great choice when you are looking to quickly setup a webpack
configuration for an application or tool with one entry point (i.e. a library).
However, there is not much flexibility in extending or scaling your
configuration with this syntax.

{{{heading(Usage Single Entry)}}}

: entry: string|Array<string>

{{{subheading(webpack.config.js Single Entry)}}}

#+begin_src js
module.exports = {
  entry: './path/to/my/entry/file.js'
};
#+end_src

The single entry syntax for the =entry= property is a shorthand for:

#+begin_src js
module.exports = {
  entry: {
    main: './path/to/my/entry/file.js'
  }
};
#+end_src

#+cindex:multi-main entry
#+cindex:multiple dependent files
#+cindex:chunk, dependency graph
Passing an array of file paths to the =entry= property creates what is known as
a "multi-main entry".  This is useful when you would like to inject multiple
dependent files together and graph their dependencies into one "chunk".

*** Object Syntax
#+cindex:object syntax, @code{entry}
#+cindex:@code{entry} property, object syntax
The object syntax is more verbose.  However, this is the most scalable way of
defining =entry/entries= in your application.

{{{heading(Usage for Object Syntax)}}}

: entry: {[entryChunkName: string]: string|Array<string>}

#+caption:webpack.config.js Entry Object Syntax example
#+name:webpack-config-entry-object-syntax
#+begin_src js
module.exports = {
  entry: {
    app: './src/app.js',
    adminApp: './src/adminApp.js'
  }
};
#+end_src

*** Scenarios
**** Separate App and Vendor Entries
In webpack version < 4 it was common to add vendors as a separate entry point
to compile it as a separate file (in combination with the ~CommonsChunkPlugin~).

This is discouraged in webpack 4.  Instead, the =optimization.splitChunks=
option takes care of separating vendors and app modules and creating a separate
file.  Do not create an entry for vendors or other stuff that is not the
starting point of execution.

**** Multi-page Application
As a rule of thumb: Use exactly one entry point for each HTML document.

#+cindex:multi-page application
#+cindex:scenario, mutli-page application
#+caption:webpack.config.js Entry Multi-page App Scenario
#+name:webpack-config-entry-multi-page-app-scenario
#+begin_src js
module.exports = {
  entry: {
    pageOne: './src/pageOne/index.js',
    pageTwo: './src/pageTwo/index.js',
    pageThree: './src/pageThree/index.js'
  }
};
#+end_src

#+cindex:dependency graphs, multiple
We are telling {{{command(webpack)}}} that we would like 3 separate dependency
graphs.  In a multi-page application, the server is going to fetch a new HTML
document for you.  The page reloads this new document and assets are
redownloaded.  However, this gives us the unique opportunity to do multiple
things:

  #+cindex:@code{optimization.splitChunks}
  #+cindex:shared application code
  #+cindex:multi-page applications
- ~optimization.splitChunks~ :: use this to create bundles of shared
     application code between each page.  Multi-page applications that reuse a
     lot of code/modules between entry points can greatly benefit from these
     techniques, as the number of entry points increases.

** Output
#+cindex:@code{output} configuration
#+attr_texinfo: :indic code
- output ::

            =output= configuration options tells {{{command(webpack)}}} how to
            write the compiled files to disk.  While there can be multiple
            =entry= points, only one =output= configuration is specified.

            The minimum requirement for the output property in your webpack
            config is to set its value to an object including the following
            property:

            - =filename= : <'bundle.js'>

            #+begin_src js
            module.exports = {
                output: {
                    filename: 'bundle.js',
                }
            };
            #+end_src

            This configuration would output a single ~bundle.js~ file into the
            ~dist~ directory.


{{{heading(Multiple Entry Points)}}}

#+cindex:substitutions
#+cindex:chunk
#+cindex:CommonsChunkPlugin
If your configuration creates more than a single "chunk" (as with multiple
entry points or when using plugins like CommonsChunkPlugin), you should use
=substitutions= to ensure that each file has a unique name.

#+begin_src js
module.exports = {
  entry: {
    app: './src/app.js',
    search: './src/search.js'
  },
  output: {
    filename: '[name].js',
    path: __dirname + '/dist'
  }
};

// writes to disk: ./dist/app.js, ./dist/search.js
#+end_src

~[name]~ substitutes the entry names for the output names.

{{{heading(Advanced)}}}

Here's a more complicated example of using a CDN and hashes for assets:

#+begin_src js
module.exports = {
  //...
  output: {
    path: '/home/proj/cdn/assets/[hash]',
    publicPath: 'https://cdn.example.com/assets/[hash]/'
  }
};
#+end_src

In cases where the eventual =publicPath= of output files isn't known at compile
time, it can be left blank and set dynamically at runtime via the
~__webpack_public_path__~ variable in the entry point file:

#+begin_src js
__webpack_public_path__ = myRuntimePublicPath;

// rest of your application entry
#+end_src

** Loaders
#+cindex:loader
#+cindex:pre-process
#+cindex:tasks
Loaders are transformations that are applied on the source code of a module.
They allow you to pre-process files as you import or “load” them.  Thus,
loaders are kind of like “tasks” in other build tools and provide a powerful
way to handle front-end build steps.  Loaders can transform files from a
different language (like TypeScript) to JavaScript or inline images as data
URLs.  Loaders even allow you to do things like import CSS files directly from
your JavaScript modules!

{{{heading(Install Loaders)}}}

#+cindex:install loader
For example, you can use loaders to tell webpack to load a CSS file or to
convert TypeScript to JavaScript.  To do this, you would start by installing the
loaders you need:

#+begin_src sh
npm install --save-dev css-loader
npm install --save-dev ts-loader
#+end_src

And then instruct webpack to use the =css-loader= for every ~.css~ file and the
=ts-loader= for all ~.ts~ files:

#+name:webpack-config-loader-example
#+begin_src js
module.exports = {
  module: {
    rules: [
      { test: /\.css$/, use: 'css-loader' },
      { test: /\.ts$/, use: 'ts-loader' }
    ]
  }
};
#+end_src

*** Using Loaders

There are three ways to use loaders in your application:

- Configuration :: Specify them in your webpack.config.js file (recommended
                   way)

- Inline :: Specify them explicitly in each ~import~ statement

- CLI :: Specify them within a shell command


**** Configuration

#+cindex:@code{module.rules}
=module.rules= allows you to specify several loaders within your webpack
configuration.  This is a concise way to display loaders, and helps to maintain
clean code.  It also offers you a full overview of each respective loader.

Loaders are evaluated/executed from right to left (or from bottom to top).  In
the example below execution starts with =sass-loader=, continues with
=css-loader= and finally ends with =style-loader=.

#+name:webpack-config-loader-order
#+begin_src js
module.exports = {
  module: {
    rules: [
      {
        test: /\.css$/,
        use: [
          // style-loader
          { loader: 'style-loader' },
          // css-loader
          {
            loader: 'css-loader',
            options: {
              modules: true
            }
          },
          // sass-loader
          { loader: 'sass-loader' }
        ]
      }
    ]
  }
};
#+end_src

**** Inline
It's possible to specify loaders in an ~import~ statement, or any equivalent
"importing" method.  Separate loaders from the resource with =!=.  Each part is
resolved relative to the current directory.

: import Styles from 'style-loader!css-loader?modules!./styles.css';

It's possible to override any loaders, preLoaders and postLoaders from the
configuration by prefixing the inline import statement:

- Prefixing with =!= will disable all configured normal loaders

- Prefixing with =!!= will disable all configured loaders (preLoaders, loaders,
  postLoaders)

- Prefixing with =-!= will disable all configured preLoaders and loaders but
  not postLoaders


Options can be passed with a query parameter, e.g. =?key=value&foo=bar=, or a
JSON object, e.g. =?{"key":"value","foo":"bar"}=.

**** CLI
You can also use loaders through the CLI:

: webpack --module-bind jade-loader --module-bind 'css=style-loader!css-loader'

This uses the =jade-loader= for ~.jade~ files, and the =style-loader= and
=css-loader= for ~.css~ files.

*** Loader Features

#+cindex:chain loaders
- Loaders can be chained.  Each loader in the chain applies transformations to
  the processed resource.  A chain is executed in reverse order.  The first
  loader passes its result (resource with applied transformations) to the next
  one, and so forth.  Finally, webpack expects JavaScript to be returned by the
  last loader in the chain.

  #+cindex:synchronous
  #+cindex:asynchronous
- Loaders can be synchronous or asynchronous.

  #+cindex:Node.js
- Loaders run in Node.js and can do everything that’s possible there.

  #+cindex:options object
  #+cindex:query parameters
- Loaders can be configured with an options object (using query parameters to
  set options is still supported but has been deprecated).

  #+cindex:export
- Normal modules can export a loader in addition to the normal ~main~ via
  ~package.json~ with the =loader= field.

- Plugins can give loaders more features.

- Loaders can emit additional arbitrary files

*** Resolving Loaders
#+cindex:resolution, loader
#+cindex:loader resolution
#+cindex:module path
Loaders follow the standard module resolution.  In most cases it will be loaded
from the module path (think ~npm install~, ~node_modules~).

#+cindex:Node.js
A loader module is expected to export a function and be written in Node.js
compatible JavaScript.  They are most commonly managed with {{{command(npm)}}},
but you can also have custom loaders as files within your application.  By
convention, loaders are usually named ~xxx-loader~ (e.g. ~json-loader~).

** Plugins
#+cindex:plugin
Plugins serve the purpose of doing anything else that a loader cannot do.

A webpack plugin is a JavaScript object that has an ~apply~ method.  This
~apply~ method is called by the webpack compiler, giving access to the entire
compilation lifecycle.  Since plugins can take arguments/options, you must pass
a ~new~ instance to the =plugins= property in your webpack configuration.

*** Using Plugins
There are multiple ways to use plugins.

**** Configuration

#+name:webpack-config-plugins-example
#+begin_src js
const HtmlWebpackPlugin = require('html-webpack-plugin'); //installed via npm
const webpack = require('webpack'); //to access built-in plugins
const path = require('path');

module.exports = {
  entry: './path/to/my/entry/file.js',
  output: {
    filename: 'my-first-webpack.bundle.js',
    path: path.resolve(__dirname, 'dist')
  },
  module: {
    rules: [
      {
        test: /\.(js|jsx)$/,
        use: 'babel-loader'
      }
    ]
  },
  plugins: [
    new webpack.ProgressPlugin(),
    new HtmlWebpackPlugin({template: './src/index.html'})
  ]
};
#+end_src

**** Node.js
#+cindex:Node.js plugin
#+cindex:Node API
#+cindex:@code{plugins} property
When using the Node API, you can also pass plugins via the =plugins= property
in the configuration.

#+name:some-node-script-js
#+begin_src js
const webpack = require('webpack'); //to access webpack runtime
const configuration = require('./webpack.config.js');

let compiler = webpack(configuration);

new webpack.ProgressPlugin().apply(compiler);

compiler.run(function(err, stats) {
  // ...
});
#+end_src

** Configuration
- See: [[https://webpack.js.org/configuration/][Configuration section]] for all supported configuration options


#+cindex:configuration file
#+cindex:webpack configuration
Webpack's configuration file is a JavaScript file that exports a =webpack=
configuration.  This configuration is then processed by webpack based upon its
defined properties.

#+cindex:Node.js
#+cindex:CommonJS module
Because it's a standard Node.js =CommonJS= module, you can do the following:

- import other files via ~require(...)~

- use utilities on npm via ~require(...)~

- use JavaScript control flow expressions, e.g. the =?:= operator

- use constants or variables for often used values

- write and execute functions to generate a part of the configuration


The following practices should be avoided:

- Access CLI arguments, when using the webpack CLI (instead write your own CLI,
  or use {{{option(--env)}}})

- Export non-deterministic values (calling webpack twice should result in the
  same output files)

- Write long configurations (instead split the configuration into multiple
  files)


#+begin_cartouche
The most important part to take away from this document is that there are many
different ways to format and style your webpack configuration. The key is to
stick with something consistent that you and your team can understand and
maintain.
#+end_cartouche

{{{heading(Examples)}}}

{{{subheading(Simple Configuration)}}}

#+caption:~webpack.config.js~ Simple Configuration Example
#+name:webpack-config-js-simple-configuration
#+begin_src js
var path = require('path');

module.exports = {
  mode: 'development',
  entry: './foo.js',
  output: {
    path: path.resolve(__dirname, 'dist'),
    filename: 'foo.bundle.js'
  }
};
#+end_src

{{{subheading(Multiple Targets)}}}

Along with exporting a single configuration as an object, function or Promise,
you can export multiple configurations.  When running {{{command(webpack)}}},
all configurations are built.  However, if you pass a name to
{{{option(--config-name)}}} flag, {{{command(webpack)}}} will only build that
specific configuration.

#+cindex:AMD
#+cindex:CommonJS
For instance, this is useful for bundling a library for multiple targets such
as AMD and CommonJS:

#+caption:~webpack.config.js~ Multiple targets example
#+name:webpack-config-js-multiple-targets
#+begin_src js
module.exports = [{
  output: {
    filename: './dist-amd.js',
    libraryTarget: 'amd'
  },
  name: 'amd',
  entry: './app.js',
  mode: 'production',
}, {
  output: {
    filename: './dist-commonjs.js',
    libraryTarget: 'commonjs'
  },
  name: 'commonjs',
  entry: './app.js',
  mode: 'production',
}];
#+end_src

** Modules

** Module Resolution

** Dependency Graph

** Targets

** The Manifest

** Hot Module Replacement

** Module Bundler Resources
For a better understanding of the ideas behind module bundlers and how they
work under the hood, consult these resources:

- [[https://www.youtube.com/watch?v=UNMkLHzofQI][Manually Bundling an Application]]

- [[https://www.youtube.com/watch?v=Gc9-7PBqOC8][Live Coding a Simple Module Bundler]]

- [[https://github.com/ronami/minipack][Detailed Explanation of a Simple Module Bundler]]
* Concept Index
:PROPERTIES:
:unnumbered: t
:index:    cp
:END:
* Macro Definitions                                                :noexport:
#+macro: heading @@texinfo:@heading@@ $1
#+macro: subheading @@texinfo:@subheading@@ $1
#+macro: command @@texinfo:@code{@@$1@@texinfo:}@@
#+macro: noindent @@texinfo:@noindent @@
#+macro: option @@texinfo:@option{@@$1@@texinfo:}@@

* Local Variables                                                  :noexport:
# Local Variables:
# fill-column:79
# time-stamp-pattern:"8/^\\#\\+date:%:y-%02m-%02d %02H:%02M$"
# End:
