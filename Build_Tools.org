# -*- mode:org -*-

#+title:JavaScript Build Tools
#+date:2019-08-27 22:42
#+macro: version Version 0.0.13

* NPM
** About NPM
** Getting Started
** Packages and Modules
** Integrations
** Orgs
** CLI Documentation
*** CLI Commands
*** Configuring NPM
- [[https://docs.npmjs.com/cli-documentation/files][CLI Documentation->Configuring NPM]]

**** Folder Structure Used by NPM

**** NPMRC---The NPM Config Files

**** Package-Lock.json---A Manifestation of the Manifest

**** NPM-Package.json---Specifics of npm's package.json handling
- [[https://docs.npmjs.com/files/package.json][Home Page]]

All you need to know about what’s required in your ~package.json~ file.  It
must be actual JSON.  A lot of the behavior described in this document is
affected by the config settings described in [[*Using NPM][npm-config]].

***** Name and Version
If you plan to publish your package, the most important things in your
~package.json~ are the =name= and =version= fields as they will be required.
If you don’t plan to publish your package, the name and version fields are
optional.

The =name= and =version= together form an identifier that is assumed to be
completely unique.  Changes to the package should come along with changes to
the version.

****** Name
The name is what your thing is called.  Some rules:

- The name must be less than or equal to 214 characters.  This includes the
  scope for scoped packages.

- The name can’t start with a dot or an underscore.

- New packages must not have uppercase letters in the name.

- The name ends up being part of a URL, an argument on the command line, and a
  folder name.  Therefore, the name can’t contain any non-URL-safe characters.


Some tips:

- Don’t use the same name as a core Node module.

- Don’t put “js” or “node” in the name.  It’s assumed that it’s ~js~, since
  you’re writing a ~package.json~ file, and you can specify the engine using
  the “engines” field.  (See below.)

- The name will probably be passed as an argument to ~require()~, so it should
  be something short, but also reasonably descriptive.

- You may want to check the [[https://www.npmjs.com/][npm registry]] to see if there’s something by that
  name already, before you get too attached to it.

- A name can be optionally prefixed by a scope, e.g. ~@myorg/mypackage~.  See
  [[https://docs.npmjs.com/misc/scope][npm-scope]] for more detail.

****** Version
Version must be parseable by {{{command(node-semver)}}}, which is bundled with
{{{command(npm)}}} as a dependency.  (=npm install semver= to use it
yourself.).  More on version numbers and ranges at [[https://docs.npmjs.com/misc/semver][semver]].

***** Description
#+cindex:@code{description} field
#+cindex:@code{npm search}
The =description= field is a string designed to help people discover your
package;it will be listed in ~npm search~.

***** Keywords
#+cindex:@code{keywords} field
#+cindex:@code{npm search}
The =keywords= field is an array strings, which are also designed to help
people discovery your package as it is listed in ~npm search~.

***** Homepage
#+cindex:@code{homepage} field
The url to the project homepage.

***** Bugs
#+cindex:@code{bugs} field
#+cindex:url
#+cindex:email
#+cindex:@code{npm bugs}
The url to your project’s issue tracker and / or the email address to which
issues should be reported.  These are helpful for people who encounter issues
with your package.

#+begin_src js
bugs: {"url": <URI>, "email": <EMAIL>}
#+end_src

You can specify either one or both values.  If you want to provide only a url,
you can specify the value for “bugs” as a simple string instead of an object.
If a url is provided, it will be used by the ~npm bugs~ command.

***** License
#+cindex:@code{license} field
#+cindex:SPDX license expression
You should specify a license for your package so that people know how they are
permitted to use it, and any restrictions you’re placing on it.  If you’re
using a common license such as BSD-2-Clause or MIT, add a current SPDX license
identifier for the license you’re using, like this:

: { "license" : "BSD-3-Clause" }

You can check [[https://spdx.org/licenses/][the full list of SPDX license IDs]].  Ideally you should pick one
that is [[https://opensource.org/licenses/alphabetical][OSI]] approved.

If your package is licensed under multiple common licenses, use an [[https://www.npmjs.com/package/spdx][SPDX license
expression syntax version 2.0 string]], like this:

: { "license" : "(ISC OR GPL-3.0)" }

If you are using a license that hasn’t been assigned an SPDX identifier, or if
you are using a custom license, use a string value like this one:

: { "license" : "SEE LICENSE IN <filename>" }

Then include a file named =<filename>= at the top level of the package.

if you do not wish to grant others the right to use a private or unpublished
package under any terms:

: { "license": "UNLICENSED" }

Consider also setting ="private": true= to prevent accidental publication.

***** People Fields---Author and Contributors
#+cindex:@code{people} fields
#+cindex:@code{author} field
#+cindex:@code{contributors} field
The “author” is one person. “contributors” is an array of people.  A “person” is
an object with a “name” field and optionally “url” and “email”, like this:

#+begin_src js
{ "name" : "Barney Rubble"
, "email" : "b@rubble.com"
, "url" : "http://barnyrubble.tumblr.com/"
}
#+end_src

Or you can shorten that all into a single string, and npm will parse it for
you:

: "Barney Rubble <b@rubble.com> (http://barnyrubble.tumblr.com/)"

Both email and url are optional either way.

#+cindex:@code{maintainers} field
#+cindex:npm user info
{{{command(npm)}}} also sets a top-level “maintainers” field with your npm user
info.

***** Files
#+cindex:@code{files} field
#+cindex:file patterns
#+cindex:@file{.gitignore}
#+cindex:glob patterns
The optional files field is an array of file patterns that describes the
entries to be included when your package is installed as a dependency.  File
patterns follow a similar syntax to ~.gitignore~, but reversed: including a
file, directory, or glob pattern (=*, **/*=, and such) will make it so that
file is included in the tarball when it’s packed.  Omitting the field will make
it default to ["*"], which means it will include all files.  Some special files
and directories are also included or excluded regardless of whether they exist
in the files array: Files included with the “package.json#files” field cannot
be excluded through ~.npmignore~ or ~.gitignore~.

#+cindex:@file{.npmignore} file
You can also provide a ~.npmignore~ file in the root of your package or in
subdirectories, which will keep files from being included.  At the root of your
package it will not override the “files” field, but in subdirectories it will.
The ~.npmignore~ file works just like a ~.gitignore~.  If there is a
~.gitignore~ file, and ~.npmignore~ is missing, ~.gitignore~ ’s contents will
be used instead.

{{{heading(Files that are Always Included)}}}

Certain files are always included, regardless of settings:

- ~package.json~
- ~README~
- ~CHANGES / CHANGELOG / HISTORY~
- ~LICENSE / LICENCE~
- ~NOTICE~
- The file in the =main= field


=README=, =CHANGES=, =LICENSE= & =NOTICE= can have any case and extension.

{{{heading(Files that are Always Ignored)}}}

Some files are always ignored:

- ~.git~
- ~CVS~
- ~.svn~
- ~.hg~
- ~.lock-wscript~
- ~.wafpickle-N~
- ~.*.swp~
- ~.DS_Store~
- ~._*~
- ~npm-debug.log~
- ~.npmrc~
- ~node_modules~
- ~config.gypi~
- ~*.orig~
- ~package-lock.json~ (use shrinkwrap instead)

***** Main
#+cindex:@code{main} field
The =main= field is a module ID that is the primary entry point to your
program.  That is, if your package is named =foo=, and a user installs it, and
then does ~require("foo")~, then your main module’s =exports= object will be
returned.

This should be a module ID relative to the root of your package folder.

For most modules, it makes the most sense to have a main script and often not
much else.

***** Browser
#+cindex:@code{browser} field
#+cindex:client-side
If your module is meant to be used client-side the =browser= field should be
used instead of the =main= field.  This is helpful to hint users that it might
rely on primitives that aren’t available in Node.js modules. (e.g. window).

***** Bin
#+cindex:@code{bin} field
#+cindex:executable files
#+cindex:@code{PATH}
A lot of packages have one or more executable files that they’d like to install
into the {{{var(PATH)}}}.  {{{command(npm)}}} makes this pretty easy (in fact,
it uses this feature to install the “npm” executable.)

To use this, supply a =bin= field in your ~package.json~ which is a map of
command name to local file name.  On install, {{{command(npm)}}} will symlink
that file into ~prefix/bin~ for global installs, or ~./node_modules/.bin/~ for
local installs.

For example, myapp could have this:

: { "bin" : { "myapp" : "./cli.js" } }

So, when you install =myapp=, it’ll create a symlink from the ~cli.js~ script
to ~/usr/local/bin/myapp~.

#+cindex:script
If you have a single executable, and its name should be the name of the
package, then you can just supply it as a string.  For example:

#+begin_src js
{ "name": "my-program"
, "version": "1.2.5"
, "bin": "./path/to/program" }
#+end_src

would be the same as this:

#+begin_src js
{ "name": "my-program"
, "version": "1.2.5"
, "bin" : { "my-program" : "./path/to/program" } }
#+end_src

Make sure that your file(s) referenced in bin starts with ~#!/usr/bin/env
node~, otherwise the scripts are started without the node executable!

**** Shrinkwrap.json---A Publishable Lockfile

*** Using NPM

* Babel
** Description
{{{heading(Babel is a JavaScript compiler)}}}

#+cindex:Babel
#+cindex:ECMAScript 2015
Babel is a toolchain that is mainly used to convert ECMAScript 2015+ code into
a backwards compatible version of JavaScript in current and older browsers or
environments.

Here are the main things Babel can do for you:

- Transform syntax

- Polyfill features that are missing in your target environment (through
  =@babel/polyfill=)

* WebPack
- [[https://webpack.js.org][WebPack Home]]


{{{heading(Webpack Concepts)}}}

#+cindex:bundler
#+cindex:module bundler
#+cindex:dependency graph
{{{command(webpack)}}} is a static module bundler for modern JavaScript
applications.  When {{{command(webpack)}}} processes your application, it
internally builds a *dependency graph* which maps every module your project
needs and generates one or more bundles.  Since version 4.0.0,
{{{command(webpack)}}} does not require a configuration file to bundle your
project.

** Guides
*** Getting Started
#+cindex:modules, compile
#+cindex:compile modules
{{{command(webpack)}}} is used to compile JavaScript modules.

{{{noindent}}}You can interface with {{{command(webpack)}}} either from its CLI
or API.

**** Basic Setup
Create a directory, initialize {{{command(npm)}}}, install
{{{command(webpack)}}} locally, and install the {{{command(webpack-cli)}}}.

#+caption:Webpack Basic Setup
#+name:webpack-basic-setup
#+header: :results output :exports results
#+begin_src sh
mkdir -p examples/guides/getting-started/webpack-demo
cd examples/guides/getting-started/webpack-demo
yarn init -yp
yarn add --dev webpack webpack-cli
#+end_src

Now create the following directory structure, files and their contents:

#+begin_example
webpack-demo
  |- package.json
+ |- index.html
+ |- /src
+   |- index.js
#+end_example

{{{heading(Project)}}}

{{{subheading(src/index.js)}}}

#+caption:src/index.js
#+name:src-index.js
#+header: :mkdirp yes
#+begin_src js :tangle examples/guides/getting-started/webpack-demo/src/index.js
function component() {
  const element = document.createElement('div');

  // Lodash, currently included via a script, is required for this line to work
  element.innerHTML = _.join(['Hello', 'webpack'], ' ');

  return element;
}

document.body.appendChild(component());
#+end_src

#+caption: index.html
#+name:index.html
#+header: :mkdirp yes
#+begin_src js :tangle examples/guides/getting-started/webpack-demo/index.html
<!doctype html>
<html>
  <head>
    <title>Getting Started</title>
    <script src="https://unpkg.com/lodash@4.16.6"></script>
  </head>
  <body>
    <script src="./src/index.js"></script>
  </body>
</html>
#+end_src

**** Package.json After Basic Setup

{{{heading(Modify package.json)}}}

Add a =private= property and remove the =main= entry.  A ~package.json~ file
marked as =private= and without a =main= entry prevents accidental publication
of the code.

#+name:remove-the-main-entry
#+header: :results output :exports results
#+begin_src sh :dir examples/guides/getting-started/webpack-demo
sed -i '' -e '/main/c\
\ \ "private": true,' package.json
#+end_src

#+name:show-package.json
#+header: :results output :exports results
#+begin_src sh :dir examples/guides/getting-started/webpack-demo
cat package.json
#+end_src

** WebPack Core Concepts
#+cindex:core concepts
To get started you only need to understand its Core Concepts:

*** Entry
#+cindex:entry point
#+cindex:default entry point
#+cindex:@code{entry} property
#+cindex:configuration
#+cindex:dependency graph
- Entry point ::

                 An entry point indicates which module {{{command(webpack)}}}
                 should use to begin building out its internal dependency
                 graph.  {{{command(webpack)}}} will figure out which other
                 modules and libraries that entry point depends on (directly
                 and indirectly).

                 The default entry point value is ~./src/index.js~.

                 You can specify a different (or multiple entry points) by
                 configuring the =entry= property in the webpack configuration.

                 #+caption:Entry Point in webpack.config.js
                 #+name:entry-webpack-config
                 #+begin_src js
                 module.exports = {
                     entry: './path/to/my/entry/file.js'
                 }
                 #+end_src

*** Output

#+cindex:@code{output} property
#+cindex:emit
#+cindex:default output path
#+cindex:main output file
- Output property ::

     The =output= property tells {{{command(webpack)}}} where to emit the
     bundles it creates and how to name these files.

     The default output path for the main output file is ~./dist/main.js~, and
     the ~./dist~ folder for any other generate files.

     You can configure this part of the process by specifying an =output= field
     in your configuration:

     #+caption:Main Output File
     #+name:main-output-webpack-config
     #+begin_src js
     const path = require('path');

     module.exports = {
       entry: './path/to/my/entry/file.js',
       output: {
         path: path.resolve(__dirname, 'dist'),
         filename: 'my-first-webpack.bundle.js'
       }
     };
     #+end_src

     #+cindex:bundle name
     #+cindex:bundle path
     We use the ~output.filename~ and the ~output.path~ properties to tell
     {{{command(webpack)}}} the name of our bundle and where we want it to be
     emitted to.

     #+cindex:@code{path} module
     #+cindex:Node.js module, @code{path}
     The ~path~ module being imported at the top is a core Node.js module that
     gets used to manipulate file paths.

     #+attr_texinfo: :options Path resolve ([...paths])
     #+begin_defmethod
     - ...paths :: <string> a sequence of paths or path segments

     - __dirname :: <string> from Node.js Module, ~__dirname~ is the directory
                    name of the current module.  This is the same as the
                    ~path.dirname(__filename)~.

     - Returns :: <string> absolute path


     The ~path.resolve()~ method resolves a sequence of paths or path segments
     into an absolute path.  The given sequence of paths is processed from
     right to left, with each subsequent path prepended until an absolute path
     is constructed.  If after processing all given path segments an absolute
     path has not yet been generated, the current working directory is used.
     The resulting path is normalized and trailing slashes are removed unless
     the path is resolved to the root directory.  If no path segments are
     passed, ~path.resolve()~ will return the absolute path of the current
     working directory.
     #+end_defmethod

*** Loaders
#+cindex:JSON
#+cindex:JavaScript
{{{command(webpack)}}} only understands JavaScript and JSON files.

- Loaders ::

             #+cindex:dependency graph
             /Loaders/ allow {{{command(webpack)}}} to process other types of
             files and convert them into valid modules that can be consumed by
             your application and added to the dependency graph.

             #+cindex:dependency graph
             The ability to import any type of module, e.g. ~.css~ files, is a
             feature specific to {{{command(webpack)}}} and may not be
             supported by other bundlers or task runners.  We feel this
             extension of the language is warranted as it allows developers to
             build a more accurate dependency graph.


At a high level, loaders have two properties in your webpack configuration:

- =test= property ::

     The =test= property identifies which file or files should be transformed.

- =use= property ::

     The =use= property indicates which loader should be used to do the
                    transforming.


#+caption:webpack.config.js with Module Loaders
#+name:webpack-config-with-loaders
#+begin_src js
const path = require('path');

module.exports = {
  output: {
    filename: 'my-first-webpack.bundle.js'
  },
  module: {
    rules: [
      { test: /\.txt$/,
        use: 'raw-loader'
      }
    ]
  }
};
#+end_src

The configuration above has defined a =rules= property for a single module with
two required properties: =test= and =use=.  This tells webpack's compiler the
following:

#+begin_quote
"webpack compiler, when you come across a path that resolves to a '.txt' file
inside of a ~require()/import~ statement, use the ~raw~ -loader to transform it
before you add it to the bundle."
#+end_quote

#+cindex:rules, define
#+cindex:define rules
#+cindex:@code{module.rules}
When defining rules in your ~webpack.config.js~ file, you are defining them
under =module.rules= and not =rules=.  For your benefit, {{{command(webpack)}}}
will warn you if this is done incorrectly.

#+cindex:@code{regex}
When Using ~regex~ to match files, you may not quote it; i.e ~/\.txt$/~ is not
the same as '/\.txt$/' or "/\.txt$/".  The former instructs
{{{command(webpack)}}} to match any file that ends with ~.txt~ and the latter
instructs {{{command(webpack)}}} to match a single file with an absolute path
'.txt'; this is likely not your intention.

*** Plugins
#+cindex:plugin
While loaders are used to transform certain types of modules, /plugins/ can be
leveraged to perform a wider range of tasks like:

- bundle optimization,
- asset management and
- injection of environment variables


#+cindex:plugins list
See [[https://webpack.js.org/plugins][list of plugins]] for many available plugins.

{{{heading(Using Plugins)}}}

In order to use a plugin, you need to ~require()~ it and add it to the
=plugins= array.  Most plugins are customizable through options.  Since you can
use a plugin multiple times in a config for different purposes, you need to
create an instance of it by calling it with the ~new~ operator.

#+caption:webpack.config.js Demonstrating plugins
#+name:webpack-config-demonstrating-plugins
#+begin_src js
const HtmlWebpackPlugin = require('html-webpack-plugin'); //installed via npm
const webpack = require('webpack'); //to access built-in plugins

module.exports = {
  module: {
    rules: [
      { test: /\.txt$/, use: 'raw-loader' }
    ]
  },
  plugins: [
    new HtmlWebpackPlugin({template: './src/index.html'})
  ]
};
#+end_src

#+cindex:HTML file
#+cindex:HTML plugin
#+cindex:plugin, HTML
In the example above, the ~html-webpack-plugin~ generates an HTML file for your
application by injecting automatically all your generated bundles.

*** Mode
By setting the mode parameter to either:

- =development=
- =production= (default)
- =none=


{{{noindent}}}you can enable webpack's built-in optimizations that correspond
to each environment.  The default value is =production=.

#+caption:webpack.config.js Demonstrating Mode
#+name:webpack-config-demonstrating-mode
#+begin_src js
module.exports = {
  mode: 'production'
};
#+end_src

*** Browser Compatibility
#+cindex:browsers
#+cindex:ES5-compliant
#+cindex:IE8
#+cindex:@file{Promise}
#+cindex:@code{import()}
#+cindex:@code{reqeuire.ensure()}
#+cindex:polyfill
{{{command(webpack)}}} supports all browsers that are ES5-compliant (IE8 and
below are not supported).  {{{command(webpack)}}} needs ~Promise~ for
~import()~ and ~require.ensure()~.  If you want to support older browsers, you
will need to load a polyfill before using these expressions.

** Entry Points
#+cindex:@code{entry} property
#+cindex:configuration, entry
 There are multiple ways to define the =entry= property in your webpack
 configuration.

*** Single Entry Shorthand Syntax
#+cindex:single entry syntax
#+cindex:syntax, single entry
This is a great choice when you are looking to quickly setup a webpack
configuration for an application or tool with one entry point (i.e. a library).
However, there is not much flexibility in extending or scaling your
configuration with this syntax.

{{{heading(Usage Single Entry)}}}

: entry: string|Array<string>

{{{subheading(webpack.config.js Single Entry)}}}

#+begin_src js
module.exports = {
  entry: './path/to/my/entry/file.js'
};
#+end_src

The single entry syntax for the =entry= property is a shorthand for:

#+begin_src js
module.exports = {
  entry: {
    main: './path/to/my/entry/file.js'
  }
};
#+end_src

#+cindex:multi-main entry
#+cindex:multiple dependent files
#+cindex:chunk, dependency graph
Passing an array of file paths to the =entry= property creates what is known as
a "multi-main entry".  This is useful when you would like to inject multiple
dependent files together and graph their dependencies into one "chunk".

*** Object Syntax
#+cindex:object syntax, @code{entry}
#+cindex:@code{entry} property, object syntax
The object syntax is more verbose.  However, this is the most scalable way of
defining =entry/entries= in your application.

{{{heading(Usage for Object Syntax)}}}

: entry: {[entryChunkName: string]: string|Array<string>}

#+caption:webpack.config.js Entry Object Syntax example
#+name:webpack-config-entry-object-syntax
#+begin_src js
module.exports = {
  entry: {
    app: './src/app.js',
    adminApp: './src/adminApp.js'
  }
};
#+end_src

*** Scenarios
**** Separate App and Vendor Entries
In webpack version < 4 it was common to add vendors as a separate entry point
to compile it as a separate file (in combination with the ~CommonsChunkPlugin~).

This is discouraged in webpack 4.  Instead, the =optimization.splitChunks=
option takes care of separating vendors and app modules and creating a separate
file.  Do not create an entry for vendors or other stuff that is not the
starting point of execution.

**** Multi-page Application
As a rule of thumb: Use exactly one entry point for each HTML document.

#+cindex:multi-page application
#+cindex:scenario, mutli-page application
#+caption:webpack.config.js Entry Multi-page App Scenario
#+name:webpack-config-entry-multi-page-app-scenario
#+begin_src js
module.exports = {
  entry: {
    pageOne: './src/pageOne/index.js',
    pageTwo: './src/pageTwo/index.js',
    pageThree: './src/pageThree/index.js'
  }
};
#+end_src

#+cindex:dependency graphs, multiple
We are telling {{{command(webpack)}}} that we would like 3 separate dependency
graphs.  In a multi-page application, the server is going to fetch a new HTML
document for you.  The page reloads this new document and assets are
redownloaded.  However, this gives us the unique opportunity to do multiple
things:

  #+cindex:@code{optimization.splitChunks}
  #+cindex:shared application code
  #+cindex:multi-page applications
- ~optimization.splitChunks~ :: use this to create bundles of shared
     application code between each page.  Multi-page applications that reuse a
     lot of code/modules between entry points can greatly benefit from these
     techniques, as the number of entry points increases.

** Output
#+cindex:@code{output} configuration
#+attr_texinfo: :indic code
- output ::

            =output= configuration options tells {{{command(webpack)}}} how to
            write the compiled files to disk.  While there can be multiple
            =entry= points, only one =output= configuration is specified.

            The minimum requirement for the output property in your webpack
            config is to set its value to an object including the following
            property:

            - =filename= : <'bundle.js'>

            #+begin_src js
            module.exports = {
                output: {
                    filename: 'bundle.js',
                }
            };
            #+end_src

            This configuration would output a single ~bundle.js~ file into the
            ~dist~ directory.


{{{heading(Multiple Entry Points)}}}

#+cindex:substitutions
#+cindex:chunk
#+cindex:CommonsChunkPlugin
If your configuration creates more than a single "chunk" (as with multiple
entry points or when using plugins like CommonsChunkPlugin), you should use
=substitutions= to ensure that each file has a unique name.

#+begin_src js
module.exports = {
  entry: {
    app: './src/app.js',
    search: './src/search.js'
  },
  output: {
    filename: '[name].js',
    path: __dirname + '/dist'
  }
};

// writes to disk: ./dist/app.js, ./dist/search.js
#+end_src

~[name]~ substitutes the entry names for the output names.

{{{heading(Advanced)}}}

Here's a more complicated example of using a CDN and hashes for assets:

#+begin_src js
module.exports = {
  //...
  output: {
    path: '/home/proj/cdn/assets/[hash]',
    publicPath: 'https://cdn.example.com/assets/[hash]/'
  }
};
#+end_src

In cases where the eventual =publicPath= of output files isn't known at compile
time, it can be left blank and set dynamically at runtime via the
~__webpack_public_path__~ variable in the entry point file:

#+begin_src js
__webpack_public_path__ = myRuntimePublicPath;

// rest of your application entry
#+end_src

** Loaders
#+cindex:loader
#+cindex:pre-process
#+cindex:tasks
Loaders are transformations that are applied on the source code of a module.
They allow you to pre-process files as you import or “load” them.  Thus,
loaders are kind of like “tasks” in other build tools and provide a powerful
way to handle front-end build steps.  Loaders can transform files from a
different language (like TypeScript) to JavaScript or inline images as data
URLs.  Loaders even allow you to do things like import CSS files directly from
your JavaScript modules!

{{{heading(Install Loaders)}}}

#+cindex:install loader
For example, you can use loaders to tell webpack to load a CSS file or to
convert TypeScript to JavaScript.  To do this, you would start by installing the
loaders you need:

#+begin_src sh
npm install --save-dev css-loader
npm install --save-dev ts-loader
#+end_src

And then instruct webpack to use the =css-loader= for every ~.css~ file and the
=ts-loader= for all ~.ts~ files:

#+name:webpack-config-loader-example
#+begin_src js
module.exports = {
  module: {
    rules: [
      { test: /\.css$/, use: 'css-loader' },
      { test: /\.ts$/, use: 'ts-loader' }
    ]
  }
};
#+end_src

*** Using Loaders

There are three ways to use loaders in your application:

- Configuration :: Specify them in your webpack.config.js file (recommended
                   way)

- Inline :: Specify them explicitly in each ~import~ statement

- CLI :: Specify them within a shell command


**** Configuration

#+cindex:@code{module.rules}
=module.rules= allows you to specify several loaders within your webpack
configuration.  This is a concise way to display loaders, and helps to maintain
clean code.  It also offers you a full overview of each respective loader.

Loaders are evaluated/executed from right to left (or from bottom to top).  In
the example below execution starts with =sass-loader=, continues with
=css-loader= and finally ends with =style-loader=.

#+name:webpack-config-loader-order
#+begin_src js
module.exports = {
  module: {
    rules: [
      {
        test: /\.css$/,
        use: [
          // style-loader
          { loader: 'style-loader' },
          // css-loader
          {
            loader: 'css-loader',
            options: {
              modules: true
            }
          },
          // sass-loader
          { loader: 'sass-loader' }
        ]
      }
    ]
  }
};
#+end_src

**** Inline
It's possible to specify loaders in an ~import~ statement, or any equivalent
"importing" method.  Separate loaders from the resource with =!=.  Each part is
resolved relative to the current directory.

: import Styles from 'style-loader!css-loader?modules!./styles.css';

It's possible to override any loaders, preLoaders and postLoaders from the
configuration by prefixing the inline import statement:

- Prefixing with =!= will disable all configured normal loaders

- Prefixing with =!!= will disable all configured loaders (preLoaders, loaders,
  postLoaders)

- Prefixing with =-!= will disable all configured preLoaders and loaders but
  not postLoaders


Options can be passed with a query parameter, e.g. =?key=value&foo=bar=, or a
JSON object, e.g. =?{"key":"value","foo":"bar"}=.

**** CLI
You can also use loaders through the CLI:

: webpack --module-bind jade-loader --module-bind 'css=style-loader!css-loader'

This uses the =jade-loader= for ~.jade~ files, and the =style-loader= and
=css-loader= for ~.css~ files.

*** Loader Features

#+cindex:chain loaders
- Loaders can be chained.  Each loader in the chain applies transformations to
  the processed resource.  A chain is executed in reverse order.  The first
  loader passes its result (resource with applied transformations) to the next
  one, and so forth.  Finally, webpack expects JavaScript to be returned by the
  last loader in the chain.

  #+cindex:synchronous
  #+cindex:asynchronous
- Loaders can be synchronous or asynchronous.

  #+cindex:Node.js
- Loaders run in Node.js and can do everything that’s possible there.

  #+cindex:options object
  #+cindex:query parameters
- Loaders can be configured with an options object (using query parameters to
  set options is still supported but has been deprecated).

  #+cindex:export
- Normal modules can export a loader in addition to the normal ~main~ via
  ~package.json~ with the =loader= field.

- Plugins can give loaders more features.

- Loaders can emit additional arbitrary files

*** Resolving Loaders
#+cindex:resolution, loader
#+cindex:loader resolution
#+cindex:module path
Loaders follow the standard module resolution.  In most cases it will be loaded
from the module path (think ~npm install~, ~node_modules~).

#+cindex:Node.js
A loader module is expected to export a function and be written in Node.js
compatible JavaScript.  They are most commonly managed with {{{command(npm)}}},
but you can also have custom loaders as files within your application.  By
convention, loaders are usually named ~xxx-loader~ (e.g. ~json-loader~).

** Plugins
#+cindex:plugin
Plugins serve the purpose of doing anything else that a loader cannot do.

A webpack plugin is a JavaScript object that has an ~apply~ method.  This
~apply~ method is called by the webpack compiler, giving access to the entire
compilation lifecycle.  Since plugins can take arguments/options, you must pass
a ~new~ instance to the =plugins= property in your webpack configuration.

*** Using Plugins
There are multiple ways to use plugins.

**** Configuration

#+name:webpack-config-plugins-example
#+begin_src js
const HtmlWebpackPlugin = require('html-webpack-plugin'); //installed via npm
const webpack = require('webpack'); //to access built-in plugins
const path = require('path');

module.exports = {
  entry: './path/to/my/entry/file.js',
  output: {
    filename: 'my-first-webpack.bundle.js',
    path: path.resolve(__dirname, 'dist')
  },
  module: {
    rules: [
      {
        test: /\.(js|jsx)$/,
        use: 'babel-loader'
      }
    ]
  },
  plugins: [
    new webpack.ProgressPlugin(),
    new HtmlWebpackPlugin({template: './src/index.html'})
  ]
};
#+end_src

**** Node.js
#+cindex:Node.js plugin
#+cindex:Node API
#+cindex:@code{plugins} property
When using the Node API, you can also pass plugins via the =plugins= property
in the configuration.

#+name:some-node-script-js
#+begin_src js
const webpack = require('webpack'); //to access webpack runtime
const configuration = require('./webpack.config.js');

let compiler = webpack(configuration);

new webpack.ProgressPlugin().apply(compiler);

compiler.run(function(err, stats) {
  // ...
});
#+end_src

** Configuration
- See: [[https://webpack.js.org/configuration/][Configuration section]] for all supported configuration options


#+cindex:configuration file
#+cindex:webpack configuration
Webpack's configuration file is a JavaScript file that exports a =webpack=
configuration.  This configuration is then processed by webpack based upon its
defined properties.

#+cindex:Node.js
#+cindex:CommonJS module
Because it's a standard Node.js =CommonJS= module, you can do the following:

- import other files via ~require(...)~

- use utilities on npm via ~require(...)~

- use JavaScript control flow expressions, e.g. the =?:= operator

- use constants or variables for often used values

- write and execute functions to generate a part of the configuration


The following practices should be avoided:

- Access CLI arguments, when using the webpack CLI (instead write your own CLI,
  or use {{{option(--env)}}})

- Export non-deterministic values (calling webpack twice should result in the
  same output files)

- Write long configurations (instead split the configuration into multiple
  files)


#+begin_cartouche
The most important part to take away from this document is that there are many
different ways to format and style your webpack configuration. The key is to
stick with something consistent that you and your team can understand and
maintain.
#+end_cartouche

{{{heading(Examples)}}}

{{{subheading(Simple Configuration)}}}

#+caption:~webpack.config.js~ Simple Configuration Example
#+name:webpack-config-js-simple-configuration
#+begin_src js
var path = require('path');

module.exports = {
  mode: 'development',
  entry: './foo.js',
  output: {
    path: path.resolve(__dirname, 'dist'),
    filename: 'foo.bundle.js'
  }
};
#+end_src

{{{subheading(Multiple Targets)}}}

Along with exporting a single configuration as an object, function or Promise,
you can export multiple configurations.  When running {{{command(webpack)}}},
all configurations are built.  However, if you pass a name to
{{{option(--config-name)}}} flag, {{{command(webpack)}}} will only build that
specific configuration.

#+cindex:AMD
#+cindex:CommonJS
For instance, this is useful for bundling a library for multiple targets such
as AMD and CommonJS:

#+caption:~webpack.config.js~ Multiple targets example
#+name:webpack-config-js-multiple-targets
#+begin_src js
module.exports = [{
  output: {
    filename: './dist-amd.js',
    libraryTarget: 'amd'
  },
  name: 'amd',
  entry: './app.js',
  mode: 'production',
}, {
  output: {
    filename: './dist-commonjs.js',
    libraryTarget: 'commonjs'
  },
  name: 'commonjs',
  entry: './app.js',
  mode: 'production',
}];
#+end_src

** Modules
{{{heading(WebPack Modules)}}}

#+cindex:Node.js
#+cindex:modular programming
#+cindex:module
#+cindex:modular JavaScript
Node.js has supported modular programming almost since its inception.  On the
web, however, support for modules has been slow to arrive.  Multiple tools
exist that support modular JavaScript on the web, with a variety of benefits
and limitations.  {{{command(webpack)}}} builds on lessons learned from these
systems and applies the concept of modules to any file in your project.

{{{subheading(WebPack Module Dependencies)}}}

In contrast to Node.js modules, {{{command(webpack)}}} modules can express
their dependencies in a variety of ways.  A few examples are:

#+cindex:ES2015
#+cindex:import statement
- An ES2015 import statement

  #+cindex:CommonJS
  #+cindex:@code{require()} statement
- A CommonJS ~require()~ statement

  #+cindex:AMD
  #+cindex:@code{define} statement
  #+cindex:@code{require} statement
- An AMD ~define~ and ~require~ statement

  #+cindex:@code{@@import} statement
  #+cindex:css/sass/less file
- An =@import= statement inside of a css/sass/less file.

  #+cindex:image url
  #+cindex:@code{url(...)}
  #+cindex:@code{<img src=...>}
- An image url in a stylesheet (~url(...)~) or html (~<img src=...>~) file.


{{{subheading(Supported Module Types)}}}

#+cindex:loaders
{{{command(webpack)}}} supports modules written in a variety of languages and
preprocessors, via loaders.  Loaders describe to {{{command(webpack)}}} how to
process non-JavaScript modules and include these dependencies into your
bundles.  The {{{command(webpack)}}} community has built loaders for a wide
variety of popular languages and language processors, including:

- CoffeeScript

- TypeScript

- ESNext (Babel)

- Sass

- Less

- Stylus


See [[https://webpack.js.org/loaders][Loaders]] for a full list of loaders.

Overall, {{{command(webpack)}}} provides a powerful and rich API for
customization that allows one to use {{{command(webpack)}}} for any stack,
while staying non-opinionated about your development, testing, and production
workflows.

** Module Resolution
#+cindex:resolver
A /resolver/ is a library which helps in locating a module by its absolute
path.  A module can be required as a dependency from another module as:

: import foo from 'path/to/module';
or
: require('path/to/module');

The dependency module can be from the application code or a third-party
library.  The resolver helps {{{command(webpack)}}} find the module code that
needs to be included in the bundle for every such =require/import= statement.
{{{command(webpack)}}} uses [[https://github.com/webpack/enhanced-resolve][enhanced-resolve]] to resolve file paths while
bundling modules.

*** Resolving Rules
Using [[https://github.com/webpack/enhanced-resolve][enhanced-resolve]], webpack can resolve three kinds of file paths:

{{{heading(Absolute paths)}}}

#+begin_src js
import '/home/me/file';

import 'C:\\Users\\me\\file';
#+end_src

Since we already have the absolute path to the file, no further resolution is
required.

{{{heading(Relative paths)}}}

#+begin_src js
import '../src/file1';
import './file2';
#+end_src

In this case, the directory of the resource file where the =import= or
=require= occurs is taken to be the =context= directory.  The relative path
specified in the =import/require= is joined to this =context= path to produce
the absolute path to the module.

{{{heading(Module paths)}}}

#+begin_src js
import 'module';
import 'module/lib/file';
#+end_src

Modules are searched for inside all directories specified in =resolve.modules=.
You can replace the original module path by an alternate path by creating an
alias for it using the =resolve.alias= configuration option.  Once the path is
resolved based on the above rule, the resolver checks to see if the path points
to a file or a directory.  If the path points to a file:

- If the path has a file extension, then the file is bundled straightaway.

- Otherwise, the file extension is resolved using the =resolve.extensions=
  option, which tells the resolver which extensions (eg - ~.js~, ~.jsx~) are
  acceptable for resolution.


If the path points to a folder, then the following steps are taken to find the
right file with the right extension:

- If the folder contains a =package.json= file, then fields specified in
  =resolve.mainFields= configuration option are looked up in order, and the
  first such field in ~package.json~ determines the file path.

- If there is no ~package.json~ or if the main fields do not return a valid
  path, file names specified in the ~resolve.mainFiles~ configuration option
  are looked for in order, to see if a matching filename exists in the
  =imported/required= directory.

- The file extension is then resolved in a similar way using the
  =resolve.extensions= option.


{{{command(webpack)}}} provides reasonable defaults for these options depending
on your build target.

*** Resolving Loaders
This follows the same rules as those specified for file resolution.  But the
=resolveLoader= configuration option can be used to have separate resolution
rules for loaders.

*** Caching
Every filesystem access is cached, so that multiple parallel or serial requests
to the same file occur faster.  In watch mode, only modified files are evicted
from the cache.  If watch mode is off, then the cache gets purged before every
compilation.

See [[https://webpack.js.org/configuration/resolve][Resolve API]] to learn more on the configuration options mentioned above.

** Dependency Graph
#+cindex:dependency
Any time one file /depends/ on another, webpack treats this as a dependency.
This allows webpack to take non-code assets, such as images or web fonts, and
also provide them as dependencies for your application.

When webpack processes your application, it starts from a list of modules
defined on the command line or in its config file.  Starting from these entry
points, webpack recursively builds a dependency graph that includes every
module your application needs, then bundles all of those modules into a small
number of bundles --- often, just one --- to be loaded by the browser.

#+cindex:HTTP/1.1
#+cindex:HTTP/2
#+cindex:Code Splitting
#+begin_cartouche
Bundling your application is especially powerful for HTTP/1.1 clients, as it
minimizes the number of times your app has to wait while the browser starts a
new request.  For HTTP/2, you can also use Code Splitting to achieve best
results.
#+end_cartouche

** Targets
#+cindex:target
#+cindex:deployment target
Because JavaScript can be written for both server and browser,
{{{command(webpack)}}} offers multiple /deployment targets/ that you can set in
your webpack configuration.

To set the =target= property, you simply set the =target= value in your webpack
config:

#+cindex:caption:Webpack Config Target Property
#+name:webpack.config.js-target-property
#+begin_src js
module.exports = {
  target: 'node'
};
#+end_src

In the example above, using node, {{{command(webpack)}}} will compile for usage
in a Node.js--like environment (uses Node.js require to load chunks and not
touch any built in modules like ~fs~ or ~path~).

Each /target/ has a variety of deployment/environment specific additions,
support to fit its needs.  See what [[https://webpack.js.org/configuration/target/][targets are available]].

*** Multiple Targets
Although {{{command(webpack)}}} does not support multiple strings being passed
into the =target= property, you can create an /isomorphic library/ by bundling
two separate configurations:

#+caption:Isomorphic Library for multiple targets
#+name:isomorphic-library
#+begin_src js
const path = require('path');
const serverConfig = {
  target: 'node',
  output: {
    path: path.resolve(__dirname, 'dist'),
    filename: 'lib.node.js'
  }
  //…
};

const clientConfig = {
  target: 'web', // <=== can be omitted as default is 'web'
  output: {
    path: path.resolve(__dirname, 'dist'),
    filename: 'lib.js'
  }
  //…
};

module.exports = [ serverConfig, clientConfig ];
#+end_src

The example above will create a ~lib.js~ and ~lib.node.js~ file in your ~dist~
folder.

*** Resources
As seen from the options above, there are multiple deployment targets that you
can choose from.  Below is a list of examples and resources that you can refer
to.

- [[https://github.com/TheLarkInn/compare-webpack-target-bundles][compare-webpack-target-bundles]] ::

     A great resource for testing and viewing different webpack targets. Also
     great for bug reporting.

- [[https://github.com/chentsulin/electron-react-boilerplate][Boilerplate of Electron-React Application]] ::

     A good example of a build process for electron's main process and renderer
     process.

** The Manifest
In a typical application or site built with {{{command(webpack)}}}, there are
three main types of code:

1. The source code you, and maybe your team, have written.

2. Any third-party library or "vendor" code your source is dependent on.

3. A webpack runtime and manifest that conducts the interaction of all modules.


{{{heading(Runtime)}}}

The runtime, along with the manifest data, is basically all the code
{{{command(webpack)}}} needs to connect your modularized application while it's
running in the browser.  It contains the loading and resolving logic needed to
connect your modules as they interact.  This includes connecting modules that
have already been loaded into the browser as well as logic to lazy-load the
ones that haven't.

{{{heading(Manifest)}}}

#+cindex:manifest
Once your application hits the browser in the form of ~index.html~ file, some
bundles and a variety of other assets required by your application must be
loaded and linked somehow.  That ~/src~ directory you meticulously laid out is
now bundled, minified and maybe even split into smaller chunks for lazy-loading
by webpack's optimization.  So how does {{{command(webpack)}}} manage the
interaction between all of your required modules?  This is where the manifest
data comes in...

As the compiler enters, resolves, and maps out your application, it keeps
detailed notes on all your modules.  This collection of data is called the
"Manifest," and it's what the runtime will use to resolve and load modules once
they've been bundled and shipped to the browser.  No matter which module syntax
you have chosen, those =import= or =require= statements have now become
=__webpack_require__= methods that point to module identifiers.  Using the data
in the manifest, the runtime will be able to find out where to retrieve the
modules behind the identifiers.

{{{heading(The Problem)}}}

So now you have a little bit of insight about how {{{command(webpack)}}} works
behind the scenes.  "But, how does this affect me?", you might ask.  The simple
answer is that most of the time it doesn't.  The runtime will do its thing,
utilizing the manifest, and everything will appear to just magically work once
your application hits the browser.  However, if you decide to improve the
performance of your projects by utilizing browser caching, this process will
all of a sudden become an important thing to understand.

By using content hashes within your bundle file names, you can indicate to the
browser when the content of a file has changed, thus invalidating the cache.
Once you start doing this though, you'll immediately notice some funny
behavior.  Certain hashes change even when their content apparently does not.
This is caused by the injection of the runtime and manifest, which changes
every build.

See [[https://webpack.js.org/guides/output-management/#the-manifest][the manifest section]] of our Output management guide to learn how to extract
the manifest, and read the guides below to learn more about the intricacies of
long term caching.

** Hot Module Replacement

** Module Bundler Resources
For a better understanding of the ideas behind module bundlers and how they
work under the hood, consult these resources:

- [[https://www.youtube.com/watch?v=UNMkLHzofQI][Manually Bundling an Application]]

- [[https://www.youtube.com/watch?v=Gc9-7PBqOC8][Live Coding a Simple Module Bundler]]

- [[https://github.com/ronami/minipack][Detailed Explanation of a Simple Module Bundler]]
* Concept Index
:PROPERTIES:
:unnumbered: t
:index:    cp
:END:
* Export Settings
#+options: H:4
* Macro Definitions                                                :noexport:
#+macro: heading @@texinfo:@heading@@ $1
#+macro: subheading @@texinfo:@subheading@@ $1
#+macro: command @@texinfo:@code{@@$1@@texinfo:}@@
#+macro: noindent @@texinfo:@noindent @@
#+macro: option @@texinfo:@option{@@$1@@texinfo:}@@
#+macro: var @@texinfo:@option{@@$1@@texinfo:}@@

* Local Variables                                                  :noexport:
# Local Variables:
# fill-column:79
# time-stamp-pattern:"8/^\\#\\+date:%:y-%02m-%02d %02H:%02M$"
# End:
