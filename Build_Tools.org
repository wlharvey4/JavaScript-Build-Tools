# -*- mode:org -*-

#+title:JavaScript Build Tools
#+date:2019-08-22 07:09
#+macro: version Version 0.0.3

* Babel
** Description
{{{heading(Babel is a JavaScript compiler)}}}

#+cindex:Babel
#+cindex:ECMAScript 2015
Babel is a toolchain that is mainly used to convert ECMAScript 2015+ code into
a backwards compatible version of JavaScript in current and older browsers or
environments.

Here are the main things Babel can do for you:

- Transform syntax

- Polyfill features that are missing in your target environment (through
  =@babel/polyfill=)

* WebPack
- [[https://webpack.js.org][WebPack Home]]


#+cindex:bundler
#+cindex:module bundler
#+cindex:dependency graph
{{{command(webpack)}}} is a static module bundler for modern JavaScript
applications.  When {{{command(webpack)}}} processes your application, it
internally builds a *dependency graph* which maps every module your project
needs and generates one or more bundles.  Since version 4.0.0,
{{{command(webpack)}}} does not require a configuration file to bundle your
project.

** WebPack Core Concepts
#+cindex:core concepts
To get started you only need to understand its Core Concepts:

*** Entry
#+cindex:entry point
#+cindex:default entry point
#+cindex:@code{entry} property
#+cindex:configuration
#+cindex:dependency graph
- Entry point ::

                 An entry point indicates which module {{{command(webpack)}}}
                 should use to begin building out its internal dependency
                 graph.  {{{command(webpack)}}} will figure out which other
                 modules and libraries that entry point depends on (directly
                 and indirectly).

                 The default entry point value is ~./src/index.js~.

                 You can specify a different (or multiple entry points) by
                 configuring the =entry= property in the webpack configuration.

                 #+caption:Entry Point in webpack.config.js
                 #+name:entry-webpack-config
                 #+begin_src js
                 module.exports = {
                     entry: './path/to/my/entry/file.js'
                 }
                 #+end_src

*** Output

#+cindex:@code{output} property
#+cindex:emit
#+cindex:default output path
#+cindex:main output file
- Output property ::

     The =output= property tells {{{command(webpack)}}} where to emit the
     bundles it creates and how to name these files.

     The default output path for the main output file is ~./dist/main.js~, and
     the ~./dist~ folder for any other generate files.

     You can configure this part of the process by specifying an =output= field
     in your configuration:

     #+caption:Main Output File
     #+name:main-output-webpack-config
     #+begin_src js
     const path = require('path');

     module.exports = {
       entry: './path/to/my/entry/file.js',
       output: {
         path: path.resolve(__dirname, 'dist'),
         filename: 'my-first-webpack.bundle.js'
       }
     };
     #+end_src

     #+cindex:bundle name
     #+cindex:bundle path
     We use the ~output.filename~ and the ~output.path~ properties to tell
     {{{command(webpack)}}} the name of our bundle and where we want it to be
     emitted to.

     #+cindex:@code{path} module
     #+cindex:Node.js module, @code{path}
     The ~path~ module being imported at the top is a core Node.js module that
     gets used to manipulate file paths.

     #+attr_texinfo: :options Path resolve ([...paths])
     #+begin_defmethod
     - ...paths :: <string> a sequence of paths or path segments

     - __dirname :: <string> from Node.js Module, ~__dirname~ is the directory
                    name of the current module.  This is the same as the
                    ~path.dirname(__filename)~.

     - Returns :: <string> absolute path


     The ~path.resolve()~ method resolves a sequence of paths or path segments
     into an absolute path.  The given sequence of paths is processed from
     right to left, with each subsequent path prepended until an absolute path
     is constructed.  If after processing all given path segments an absolute
     path has not yet been generated, the current working directory is used.
     The resulting path is normalized and trailing slashes are removed unless
     the path is resolved to the root directory.  If no path segments are
     passed, ~path.resolve()~ will return the absolute path of the current
     working directory.
     #+end_defmethod

*** Loaders
#+cindex:JSON
#+cindex:JavaScript
{{{command(webpack)}}} only understands JavaScript and JSON files.

- Loaders ::

             #+cindex:dependency graph
             /Loaders/ allow {{{command(webpack)}}} to process other types of
             files and convert them into valid modules that can be consumed by
             your application and added to the dependency graph.

             #+cindex:dependency graph
             The ability to import any type of module, e.g. ~.css~ files, is a
             feature specific to {{{command(webpack)}}} and may not be
             supported by other bundlers or task runners.  We feel this
             extension of the language is warranted as it allows developers to
             build a more accurate dependency graph.


At a high level, loaders have two properties in your webpack configuration:

- =test= property ::

     The =test= property identifies which file or files should be transformed.

- =use= property ::

     The =use= property indicates which loader should be used to do the
                    transforming.


#+caption:webpack.config.js with Module Loaders
#+name:webpack-config-with-loaders
#+begin_src js
const path = require('path');

module.exports = {
  output: {
    filename: 'my-first-webpack.bundle.js'
  },
  module: {
    rules: [
      { test: /\.txt$/,
        use: 'raw-loader'
      }
    ]
  }
};
#+end_src

The configuration above has defined a =rules= property for a single module with
two required properties: =test= and =use=.  This tells webpack's compiler the
following:

#+begin_quote
"webpack compiler, when you come across a path that resolves to a '.txt' file
inside of a ~require()/import~ statement, use the ~raw~ -loader to transform it
before you add it to the bundle."
#+end_quote

#+cindex:rules, define
#+cindex:define rules
#+cindex:@code{module.rules}
When defining rules in your ~webpack.config.js~ file, you are defining them
under =module.rules= and not =rules=.  For your benefit, {{{command(webpack)}}}
will warn you if this is done incorrectly.

#+cindex:@code{regex}
When Using ~regex~ to match files, you may not quote it; i.e ~/\.txt$/~ is not
the same as '/\.txt$/' or "/\.txt$/".  The former instructs
{{{command(webpack)}}} to match any file that ends with ~.txt~ and the latter
instructs {{{command(webpack)}}} to match a single file with an absolute path
'.txt'; this is likely not your intention.

*** Plugins
#+cindex:plugin
While loaders are used to transform certain types of modules, /plugins/ can be
leveraged to perform a wider range of tasks like:

- bundle optimization,
- asset management and
- injection of environment variables


#+cindex:plugins list
See [[https://webpack.js.org/plugins][list of plugins]] for many available plugins.

{{{heading(Using Plugins)}}}

In order to use a plugin, you need to ~require()~ it and add it to the
=plugins= array.  Most plugins are customizable through options.  Since you can
use a plugin multiple times in a config for different purposes, you need to
create an instance of it by calling it with the ~new~ operator.

#+caption:webpack.config.js Demonstrating plugins
#+name:webpack-config-demonstrating-plugins
#+begin_src js
const HtmlWebpackPlugin = require('html-webpack-plugin'); //installed via npm
const webpack = require('webpack'); //to access built-in plugins

module.exports = {
  module: {
    rules: [
      { test: /\.txt$/, use: 'raw-loader' }
    ]
  },
  plugins: [
    new HtmlWebpackPlugin({template: './src/index.html'})
  ]
};
#+end_src

#+cindex:HTML file
#+cindex:HTML plugin
#+cindex:plugin, HTML
In the example above, the ~html-webpack-plugin~ generates an HTML file for your
application by injecting automatically all your generated bundles.

*** Mode

*** Browser Compatibility

** Module Bundler Resources
For a better understanding of the ideas behind module bundlers and how they
work under the hood, consult these resources:

- [[https://www.youtube.com/watch?v=UNMkLHzofQI][Manually Bundling an Application]]

- [[https://www.youtube.com/watch?v=Gc9-7PBqOC8][Live Coding a Simple Module Bundler]]

- [[https://github.com/ronami/minipack][Detailed Explanation of a Simple Module Bundler]]
* Concept Index
:PROPERTIES:
:unnumbered: t
:index:    cp
:END:
* Macro Definitions                                                :noexport:
#+macro: heading @@texinfo:@heading@@ $1
#+macro: subheading @@texinfo:@subheading@@ $1
#+macro: command @@texinfo:@code{@@$1@@texinfo:}@@

* Local Variables                                                  :noexport:
# Local Variables:
# fill-column:79
# time-stamp-pattern:"8/^\\#\\+date:%:y-%02m-%02d %02H:%02M$"
# End:
