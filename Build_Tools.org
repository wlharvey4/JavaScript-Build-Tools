# -*- mode:org -*-

#+title:JavaScript Build Tools
#+date:2019-10-02 11:02
#+macro: version Version 0.0.24

* Node Package Manager---npm
“Build Amazing Things”

- [[https://www.npmjs.com][npm Home]]
- [[https://docs.npmjs.com][npm Docs]]
- [[https://docs.npmjs.com/getting-started/][npm Getting Started]]

** About NPM
** Getting Started
** Packages and Modules
** Integrations
** Orgs
** CLI Documentation
*** CLI Commands
*** Configuring NPM
- [[https://docs.npmjs.com/cli-documentation/files][CLI Documentation->Configuring NPM]]

**** Folder Structure Used by NPM

**** NPMRC---The NPM Config Files

**** Package-Lock.json---A Manifestation of the Manifest

**** NPM-Package.json---Specifics of npm's package.json handling
- [[https://docs.npmjs.com/files/package.json][Home Page]]

All you need to know about what’s required in your ~package.json~ file.  It
must be actual JSON.  A lot of the behavior described in this document is
affected by the config settings described in [[*Using NPM][npm-config]].

***** Name and Version
If you plan to publish your package, the most important things in your
~package.json~ are the =name= and =version= fields as they will be required.
If you don’t plan to publish your package, the name and version fields are
optional.

The =name= and =version= together form an identifier that is assumed to be
completely unique.  Changes to the package should come along with changes to
the version.

****** Name
The name is what your thing is called.  Some rules:

- The name must be less than or equal to 214 characters.  This includes the
  scope for scoped packages.

- The name can’t start with a dot or an underscore.

- New packages must not have uppercase letters in the name.

- The name ends up being part of a URL, an argument on the command line, and a
  folder name.  Therefore, the name can’t contain any non-URL-safe characters.


Some tips:

- Don’t use the same name as a core Node module.

- Don’t put “js” or “node” in the name.  It’s assumed that it’s ~js~, since
  you’re writing a ~package.json~ file, and you can specify the engine using
  the “engines” field.  (See below.)

- The name will probably be passed as an argument to ~require()~, so it should
  be something short, but also reasonably descriptive.

- You may want to check the [[https://www.npmjs.com/][npm registry]] to see if there’s something by that
  name already, before you get too attached to it.

- A name can be optionally prefixed by a scope, e.g. ~@myorg/mypackage~.  See
  [[https://docs.npmjs.com/misc/scope][npm-scope]] for more detail.

****** Version
Version must be parseable by {{{command(node-semver)}}}, which is bundled with
{{{command(npm)}}} as a dependency.  (=npm install semver= to use it
yourself.).  More on version numbers and ranges at [[https://docs.npmjs.com/misc/semver][semver]].

***** Description
#+cindex:@code{description} field
#+cindex:@code{npm search}
The =description= field is a string designed to help people discover your
package;it will be listed in ~npm search~.

***** Keywords
#+cindex:@code{keywords} field
#+cindex:@code{npm search}
The =keywords= field is an array strings, which are also designed to help
people discovery your package as it is listed in ~npm search~.

***** Homepage
#+cindex:@code{homepage} field
The url to the project homepage.

***** Bugs
#+cindex:@code{bugs} field
#+cindex:url
#+cindex:email
#+cindex:@code{npm bugs}
The url to your project’s issue tracker and / or the email address to which
issues should be reported.  These are helpful for people who encounter issues
with your package.

#+begin_src js
bugs: {"url": <URI>, "email": <EMAIL>}
#+end_src

You can specify either one or both values.  If you want to provide only a url,
you can specify the value for “bugs” as a simple string instead of an object.
If a url is provided, it will be used by the ~npm bugs~ command.

***** License
#+cindex:@code{license} field
#+cindex:SPDX license expression
You should specify a license for your package so that people know how they are
permitted to use it, and any restrictions you’re placing on it.  If you’re
using a common license such as BSD-2-Clause or MIT, add a current SPDX license
identifier for the license you’re using, like this:

: { "license" : "BSD-3-Clause" }

You can check [[https://spdx.org/licenses/][the full list of SPDX license IDs]].  Ideally you should pick one
that is [[https://opensource.org/licenses/alphabetical][OSI]] approved.

If your package is licensed under multiple common licenses, use an [[https://www.npmjs.com/package/spdx][SPDX license
expression syntax version 2.0 string]], like this:

: { "license" : "(ISC OR GPL-3.0)" }

If you are using a license that hasn’t been assigned an SPDX identifier, or if
you are using a custom license, use a string value like this one:

: { "license" : "SEE LICENSE IN <filename>" }

Then include a file named =<filename>= at the top level of the package.

if you do not wish to grant others the right to use a private or unpublished
package under any terms:

: { "license": "UNLICENSED" }

Consider also setting ="private": true= to prevent accidental publication.

***** People Fields---Author and Contributors
#+cindex:@code{people} fields
#+cindex:@code{author} field
#+cindex:@code{contributors} field
The “author” is one person. “contributors” is an array of people.  A “person” is
an object with a “name” field and optionally “url” and “email”, like this:

#+begin_src js
{ "name" : "Barney Rubble"
, "email" : "b@rubble.com"
, "url" : "http://barnyrubble.tumblr.com/"
}
#+end_src

Or you can shorten that all into a single string, and npm will parse it for
you:

: "Barney Rubble <b@rubble.com> (http://barnyrubble.tumblr.com/)"

Both email and url are optional either way.

#+cindex:@code{maintainers} field
#+cindex:npm user info
{{{command(npm)}}} also sets a top-level “maintainers” field with your npm user
info.

***** Files
#+cindex:@code{files} field
#+cindex:file patterns
#+cindex:@file{.gitignore}
#+cindex:glob patterns
The optional files field is an array of file patterns that describes the
entries to be included when your package is installed as a dependency.  File
patterns follow a similar syntax to ~.gitignore~, but reversed: including a
file, directory, or glob pattern (=*, **/*=, and such) will make it so that
file is included in the tarball when it’s packed.  Omitting the field will make
it default to ["*"], which means it will include all files.  Some special files
and directories are also included or excluded regardless of whether they exist
in the files array: Files included with the “package.json#files” field cannot
be excluded through ~.npmignore~ or ~.gitignore~.

#+cindex:@file{.npmignore} file
You can also provide a ~.npmignore~ file in the root of your package or in
subdirectories, which will keep files from being included.  At the root of your
package it will not override the “files” field, but in subdirectories it will.
The ~.npmignore~ file works just like a ~.gitignore~.  If there is a
~.gitignore~ file, and ~.npmignore~ is missing, ~.gitignore~ ’s contents will
be used instead.

{{{heading(Files that are Always Included)}}}

Certain files are always included, regardless of settings:

- ~package.json~
- ~README~
- ~CHANGES / CHANGELOG / HISTORY~
- ~LICENSE / LICENCE~
- ~NOTICE~
- The file in the =main= field


=README=, =CHANGES=, =LICENSE= & =NOTICE= can have any case and extension.

{{{heading(Files that are Always Ignored)}}}

Some files are always ignored:

- ~.git~
- ~CVS~
- ~.svn~
- ~.hg~
- ~.lock-wscript~
- ~.wafpickle-N~
- ~.*.swp~
- ~.DS_Store~
- ~._*~
- ~npm-debug.log~
- ~.npmrc~
- ~node_modules~
- ~config.gypi~
- ~*.orig~
- ~package-lock.json~ (use shrinkwrap instead)

***** Main
#+cindex:@code{main} field
The =main= field is a module ID that is the primary entry point to your
program.  That is, if your package is named =foo=, and a user installs it, and
then does ~require("foo")~, then your main module’s =exports= object will be
returned.

This should be a module ID relative to the root of your package folder.

For most modules, it makes the most sense to have a main script and often not
much else.

***** Browser
#+cindex:@code{browser} field
#+cindex:client-side
If your module is meant to be used client-side the =browser= field should be
used instead of the =main= field.  This is helpful to hint users that it might
rely on primitives that aren’t available in Node.js modules. (e.g. window).

***** Bin
#+cindex:@code{bin} field
#+cindex:executable files
#+cindex:@code{PATH}
A lot of packages have one or more executable files that they’d like to install
into the {{{var(PATH)}}}.  {{{command(npm)}}} makes this pretty easy (in fact,
it uses this feature to install the “npm” executable.)

To use this, supply a =bin= field in your ~package.json~ which is a map of
command name to local file name.  On install, {{{command(npm)}}} will symlink
that file into ~prefix/bin~ for global installs, or ~./node_modules/.bin/~ for
local installs.

For example, myapp could have this:

: { "bin" : { "myapp" : "./cli.js" } }

So, when you install =myapp=, it’ll create a symlink from the ~cli.js~ script
to ~/usr/local/bin/myapp~.

#+cindex:script
If you have a single executable, and its name should be the name of the
package, then you can just supply it as a string.  For example:

#+begin_src js
{ "name": "my-program"
, "version": "1.2.5"
, "bin": "./path/to/program" }
#+end_src

would be the same as this:

#+begin_src js
{ "name": "my-program"
, "version": "1.2.5"
, "bin" : { "my-program" : "./path/to/program" } }
#+end_src

Make sure that your file(s) referenced in bin starts with ~#!/usr/bin/env
node~, otherwise the scripts are started without the node executable!

**** Shrinkwrap.json---A Publishable Lockfile

*** Using NPM

* Node Version Manager---nvm
“Node Version Manager - POSIX-compliant bash script to manage multiple active
node.js versions”

- https://github.com/nvm-sh/nvm

** Usage

{{{heading(Install a version of Node)}}}

To download, compile, and install the latest release of node, do this:

: nvm install node # "node" is an alias for the latest version

To install a specific version of node:

: nvm install 6.14.4 # or 10.10.0, 8.9.1, etc

The first version installed becomes the default.  New shells will start with
the default version of node (e.g., nvm alias default).

{{{subheading(List available versions)}}}

You can list available versions using ~ls-remote~:

: nvm ls-remote

{{{subheading(List installed versions)}}}

: nvm ls

{{{subheading(Use an installed version)}}}

And then in any new shell just use the installed version:

: nvm use node

{{{subheading(Run an installed version)}}}

Or you can just run it:

: nvm run node --version

Or, you can run any arbitrary command in a subshell with the desired version of
node:

: nvm exec 4.2 node --version

{{{subheading(Path of installed version)}}}

You can also get the path to the executable to where it was installed:

: nvm which 5.0

{{{heading(Use special default aliases)}}}

In place of a version pointer like "0.10" or "5.0" or "4.2.1", you can use the
following special default aliases with the above commands:

- ~node~ :: this installs the latest version of node

- ~iojs~ :: this installs the latest version of io.js


Node has a schedule for long-term support (LTS).  You can reference LTS
versions in aliases and ~.nvmrc~ files with the notation =lts/*= for the latest
LTS, and =lts/argon= for LTS releases from the "argon" line, for example.

Any time your local copy of nvm connects to https://nodejs.org, it will
re-create the appropriate local aliases for all available LTS lines.  These
aliases (stored under $NVM_DIR/alias/lts), are managed by nvm, and you should
not modify, remove, or create these files - expect your changes to be undone,
and expect meddling with these files to cause bugs that will likely not be
supported.

{{{heading(Migrating global packages while installing)}}}

To install a new version of Node.js and migrate npm packages from a previous
version:

: nvm install node --reinstall-packages-from=node
: nvm install 6 --reinstall-packages-from=5

Note that reinstalling packages explicitly does not update the npm version —
this is to ensure that npm isn't accidentally upgraded to a broken version for
the new node version.  To update npm at the same time add the --latest-npm
flag, like this:

: nvm install lts/* --reinstall-packages-from=default --latest-npm

{{{noindent}}}or, you can at any time run the following command to get the
latest supported npm version on the current node version:

: nvm install-latest-npm

{{{heading(Error: “npm does not support Node.js”)}}}

If you've already gotten an error to the effect of "npm does not support
Node.js", you'll need to:

1. revert to a previous node version 
   : nvm ls & nvm use <your latest _working_ version from the ls>

2. delete the newly created node version
   : nvm uninstall <your _broken_ version of node from the ls>

3. re-run your ~nvm install~ with the {{{option(--latest-npm)}}} flag.

* Yarn
“Fast, Reliable, and Secure Dependency Management”

The currently installed Yarn version is src_sh{yarn --version}.

- [[https://yarnpkg.com/en/][Yarn Home]]
- [[https://yarnpkg.com/en/docs/getting-started][Yarn Getting Started]]
- [[https://yarnpkg.com/en/docs][Yarn Docs]]

* Babel
** Description
{{{heading(Babel is a JavaScript compiler)}}}

#+cindex:Babel
#+cindex:ECMAScript 2015
Babel is a toolchain that is mainly used to convert ECMAScript 2015+ code into
a backwards compatible version of JavaScript in current and older browsers or
environments.

Here are the main things Babel can do for you:

- Transform syntax

- Polyfill features that are missing in your target environment (through
  =@babel/polyfill=)

* WebPack
- [[https://webpack.js.org][WebPack Home]]


{{{heading(Webpack Concepts)}}}

#+cindex:bundler
#+cindex:module bundler
#+cindex:dependency graph
{{{command(webpack)}}} is a static module bundler for modern JavaScript
applications.  When {{{command(webpack)}}} processes your application, it
internally builds a *dependency graph* which maps every module your project
needs and generates one or more bundles.  Since version 4.0.0,
{{{command(webpack)}}} does not require a configuration file to bundle your
project.

** Guides
#+name:org-babel-tangle-file
#+header: :results output :exports results
#+begin_src emacs-lisp
(org-babel-tangle-file "Build_Tools.org")
#+end_src

*** Getting Started
#+cindex:modules, compile
#+cindex:compile modules
{{{command(webpack)}}} is used to compile JavaScript modules.

{{{noindent}}}You can interface with {{{command(webpack)}}} either from its CLI
or API.

**** Basic Setup

{{{heading(Install Webpack and Webpack CLI)}}}

1. Create a project directory and move into it:

   : mkdir examples/guides/getting-started/webpack-demo
   : cd examples/guides/getting-started/webpack-demo

2. Initialize {{{command(npm)}}}:
   : yarn init --yes --private

   The {{{option(--private)}}} option prevents the package from accidentally
   being published.

3. Install {{{command(webpack)}}} and {{{command(webpack-cli)}}} locally as
   development dependencies:

   : yarn add --dev webpack webpack-cli


#+caption:Webpack Basic Setup
#+name:webpack-basic-setup
#+header: :dir examples/guides/getting-started/webpack-demo
#+header: :results output :exports results
#+begin_src sh
#mkdir -p examples/guides/getting-started/webpack-demo
#cd examples/guides/getting-started/webpack-demo
yarn init --yes --private
yarn add webpack webpack-cli --dev
#+end_src

{{{heading(Create the Project Directory Structure)}}}

Now create the following directory structure, files and their contents, i.e.,
add a ~src~ directory for the project's ~index.js~ file, and add the project's
root HTML file, ~index.html~:

#+begin_example
webpack-demo
  |- package.json
+ |- index.html
+ |- /src
+   |- index.js
#+end_example

{{{subheading(Add Project's src/index.js File)}}}

#+caption:Install src/index.js
#+name:install-src-index.js
#+header: :mkdirp yes
#+begin_src js :tangle examples/guides/getting-started/webpack-demo/src/index.js
function component() {
  const element = document.createElement('div');

  // Lodash, currently included via a script, is required for this line to work
  element.innerHTML = _.join(['Hello', 'webpack'], ' ');

  return element;
}

document.body.appendChild(component());
#+end_src

{{{subheading(Add Project's index.html File)}}}

#+caption: Install index.html
#+name:install-index.html
#+begin_src html :tangle examples/guides/getting-started/webpack-demo/index.html
<!doctype html>
<html>
  <head>
    <title>Getting Started</title>
    <script src="https://unpkg.com/lodash@4.16.6"></script>
  </head>
  <body>
    <script src="./src/index.js"></script>
  </body>
</html>
#+end_src

***** Package.json After Basic Setup

{{{heading(Modify package.json)}}}

Remove the ~package.json~ file's =main= property:

#+name:remove-the-main-entry
#+header: :dir examples/guides/getting-started/webpack-demo
#+header: :results output :exports results
#+begin_src sh
sed -i '' -e '/main/d'
#+end_src

Let's look at what the ~package.json~ file looks like at this point:

#+name:show-package.json
#+header: :dir examples/guides/getting-started/webpack-demo
#+header: :results output :exports results
#+begin_src sh
cat package.json
#+end_src

***** Implicit Dependencies

#+cindex:dependencies, implicit
In this example, there are implicit dependencies between the =<script>= tags.
Our ~index.js~ file depends on {{{command(lodash)}}} being included in the page
before it runs.  This is because ~index.js~ never explicitly declares a need
for {{{command(lodash)}}}; it just assumes that the global variable ~_~ exists.

There are problems with managing JavaScript projects this way:

- It is not immediately apparent that the script depends on an external library.

- If a dependency is missing, or included in the wrong order, the application
  will not function properly.

- If a dependency is included but not used, the browser will be forced to
  download unnecessary code.


Let's use {{{command(webpack)}}} to manage these scripts instead.

**** Creating a Bundle
#+cindex:directory structure
#+cindex:source code directory @file{/src}
#+cindex:@file{/src} directory
#+cindex:distribution code directory @file{/dist}
#+cindex:@file{/dist} directory
First we'll tweak our directory structure slightly, separating the "source"
code (~/src~) from our "distribution" code (~/dist~).  The {{{dfn(source)}}}
code is the code that we'll write and edit.  The {{{dfn(distribution)}}} code
is the minimized and optimized output of our build process that will eventually
be loaded in the browser. Tweak the directory structure as follows:

{{{heading(Project Directory Structure)}}}

#+begin_example
 webpack-demo
  |- package.json
+ |- /dist
+   |- index.html
- |- index.html
  |- /src
    |- index.js
#+end_example

#+name:tweak-project-directory-structure
#+header: :dir examples/guides/getting-started/webpack-demo
#+header: :results output :exports both
#+begin_src sh
mkdir dist
mv index.html dist
#+end_src

***** Adding lodash as a Dependency

To bundle the {{{command(lodash)}}} dependency with ~index.js~, we'll need to
install the library locally:

#+caption:Install lodash locally
#+name:install-lodash-locally
#+header: :dir examples/guides/getting-started/webpack-demo
#+header: :results output :exports both
#+begin_src sh
yarn add lodash
#+end_src

***** Import lodash into the Script File

#+caption:Import lodash in index.js File
#+name:import-lodash-in-index.js
#+header: :dir examples/guides/getting-started/webpack-demo/src
#+header: :results silent :exports both
#+begin_src sh
sed -i '' -e '1i \
import _ from '"'"'lodash'"'"';\
\
' index.js
#+end_src

** WebPack Core Concepts
#+cindex:core concepts
To get started you only need to understand its Core Concepts:

*** Entry
#+cindex:entry point
#+cindex:default entry point
#+cindex:@code{entry} property
#+cindex:configuration
#+cindex:dependency graph
- Entry point ::

                 An entry point indicates which module {{{command(webpack)}}}
                 should use to begin building out its internal dependency
                 graph.  {{{command(webpack)}}} will figure out which other
                 modules and libraries that entry point depends on (directly
                 and indirectly).

                 The default entry point value is ~./src/index.js~.

                 You can specify a different (or multiple entry points) by
                 configuring the =entry= property in the webpack configuration.

                 #+caption:Entry Point in webpack.config.js
                 #+name:entry-webpack-config
                 #+begin_src js
                 module.exports = {
                     entry: './path/to/my/entry/file.js'
                 }
                 #+end_src

*** Output

#+cindex:@code{output} property
#+cindex:emit
#+cindex:default output path
#+cindex:main output file
- Output property ::

     The =output= property tells {{{command(webpack)}}} where to emit the
     bundles it creates and how to name these files.

     The default output path for the main output file is ~./dist/main.js~, and
     the ~./dist~ folder for any other generate files.

     You can configure this part of the process by specifying an =output= field
     in your configuration:

     #+caption:Main Output File
     #+name:main-output-webpack-config
     #+begin_src js
     const path = require('path');

     module.exports = {
       entry: './path/to/my/entry/file.js',
       output: {
         path: path.resolve(__dirname, 'dist'),
         filename: 'my-first-webpack.bundle.js'
       }
     };
     #+end_src

     #+cindex:bundle name
     #+cindex:bundle path
     We use the ~output.filename~ and the ~output.path~ properties to tell
     {{{command(webpack)}}} the name of our bundle and where we want it to be
     emitted to.

     #+cindex:@code{path} module
     #+cindex:Node.js module, @code{path}
     The ~path~ module being imported at the top is a core Node.js module that
     gets used to manipulate file paths.

     #+attr_texinfo: :options Path resolve ([...paths])
     #+begin_defmethod
     - ...paths :: <string> a sequence of paths or path segments

     - __dirname :: <string> from Node.js Module, ~__dirname~ is the directory
                    name of the current module.  This is the same as the
                    ~path.dirname(__filename)~.

     - Returns :: <string> absolute path


     The ~path.resolve()~ method resolves a sequence of paths or path segments
     into an absolute path.  The given sequence of paths is processed from
     right to left, with each subsequent path prepended until an absolute path
     is constructed.  If after processing all given path segments an absolute
     path has not yet been generated, the current working directory is used.
     The resulting path is normalized and trailing slashes are removed unless
     the path is resolved to the root directory.  If no path segments are
     passed, ~path.resolve()~ will return the absolute path of the current
     working directory.
     #+end_defmethod

*** Loaders
#+cindex:JSON
#+cindex:JavaScript
{{{command(webpack)}}} only understands JavaScript and JSON files.

- Loaders ::

             #+cindex:dependency graph
             /Loaders/ allow {{{command(webpack)}}} to process other types of
             files and convert them into valid modules that can be consumed by
             your application and added to the dependency graph.

             #+cindex:dependency graph
             The ability to import any type of module, e.g. ~.css~ files, is a
             feature specific to {{{command(webpack)}}} and may not be
             supported by other bundlers or task runners.  We feel this
             extension of the language is warranted as it allows developers to
             build a more accurate dependency graph.


At a high level, loaders have two properties in your webpack configuration:

- =test= property ::

     The =test= property identifies which file or files should be transformed.

- =use= property ::

     The =use= property indicates which loader should be used to do the
                    transforming.


#+caption:webpack.config.js with Module Loaders
#+name:webpack-config-with-loaders
#+begin_src js
const path = require('path');

module.exports = {
  output: {
    filename: 'my-first-webpack.bundle.js'
  },
  module: {
    rules: [
      { test: /\.txt$/,
        use: 'raw-loader'
      }
    ]
  }
};
#+end_src

The configuration above has defined a =rules= property for a single module with
two required properties: =test= and =use=.  This tells webpack's compiler the
following:

#+begin_quote
"webpack compiler, when you come across a path that resolves to a '.txt' file
inside of a ~require()/import~ statement, use the ~raw~ -loader to transform it
before you add it to the bundle."
#+end_quote

#+cindex:rules, define
#+cindex:define rules
#+cindex:@code{module.rules}
When defining rules in your ~webpack.config.js~ file, you are defining them
under =module.rules= and not =rules=.  For your benefit, {{{command(webpack)}}}
will warn you if this is done incorrectly.

#+cindex:@code{regex}
When Using ~regex~ to match files, you may not quote it; i.e ~/\.txt$/~ is not
the same as '/\.txt$/' or "/\.txt$/".  The former instructs
{{{command(webpack)}}} to match any file that ends with ~.txt~ and the latter
instructs {{{command(webpack)}}} to match a single file with an absolute path
'.txt'; this is likely not your intention.

*** Plugins
#+cindex:plugin
While loaders are used to transform certain types of modules, /plugins/ can be
leveraged to perform a wider range of tasks like:

- bundle optimization,
- asset management and
- injection of environment variables


#+cindex:plugins list
See [[https://webpack.js.org/plugins][list of plugins]] for many available plugins.

{{{heading(Using Plugins)}}}

In order to use a plugin, you need to ~require()~ it and add it to the
=plugins= array.  Most plugins are customizable through options.  Since you can
use a plugin multiple times in a config for different purposes, you need to
create an instance of it by calling it with the ~new~ operator.

#+caption:webpack.config.js Demonstrating plugins
#+name:webpack-config-demonstrating-plugins
#+begin_src js
const HtmlWebpackPlugin = require('html-webpack-plugin'); //installed via npm
const webpack = require('webpack'); //to access built-in plugins

module.exports = {
  module: {
    rules: [
      { test: /\.txt$/, use: 'raw-loader' }
    ]
  },
  plugins: [
    new HtmlWebpackPlugin({template: './src/index.html'})
  ]
};
#+end_src

#+cindex:HTML file
#+cindex:HTML plugin
#+cindex:plugin, HTML
In the example above, the ~html-webpack-plugin~ generates an HTML file for your
application by injecting automatically all your generated bundles.

*** Mode
By setting the mode parameter to either:

- =development=
- =production= (default)
- =none=


{{{noindent}}}you can enable webpack's built-in optimizations that correspond
to each environment.  The default value is =production=.

#+caption:webpack.config.js Demonstrating Mode
#+name:webpack-config-demonstrating-mode
#+begin_src js
module.exports = {
  mode: 'production'
};
#+end_src

*** Browser Compatibility
#+cindex:browsers
#+cindex:ES5-compliant
#+cindex:IE8
#+cindex:@file{Promise}
#+cindex:@code{import()}
#+cindex:@code{reqeuire.ensure()}
#+cindex:polyfill
{{{command(webpack)}}} supports all browsers that are ES5-compliant (IE8 and
below are not supported).  {{{command(webpack)}}} needs ~Promise~ for
~import()~ and ~require.ensure()~.  If you want to support older browsers, you
will need to load a polyfill before using these expressions.

** Entry Points
#+cindex:@code{entry} property
#+cindex:configuration, entry
 There are multiple ways to define the =entry= property in your webpack
 configuration.

*** Single Entry Shorthand Syntax
#+cindex:single entry syntax
#+cindex:syntax, single entry
This is a great choice when you are looking to quickly setup a webpack
configuration for an application or tool with one entry point (i.e. a library).
However, there is not much flexibility in extending or scaling your
configuration with this syntax.

{{{heading(Usage Single Entry)}}}

: entry: string|Array<string>

{{{subheading(webpack.config.js Single Entry)}}}

#+begin_src js
module.exports = {
  entry: './path/to/my/entry/file.js'
};
#+end_src

The single entry syntax for the =entry= property is a shorthand for:

#+begin_src js
module.exports = {
  entry: {
    main: './path/to/my/entry/file.js'
  }
};
#+end_src

#+cindex:multi-main entry
#+cindex:multiple dependent files
#+cindex:chunk, dependency graph
Passing an array of file paths to the =entry= property creates what is known as
a "multi-main entry".  This is useful when you would like to inject multiple
dependent files together and graph their dependencies into one "chunk".

*** Object Syntax
#+cindex:object syntax, @code{entry}
#+cindex:@code{entry} property, object syntax
The object syntax is more verbose.  However, this is the most scalable way of
defining =entry/entries= in your application.

{{{heading(Usage for Object Syntax)}}}

: entry: {[entryChunkName: string]: string|Array<string>}

#+caption:webpack.config.js Entry Object Syntax example
#+name:webpack-config-entry-object-syntax
#+begin_src js
module.exports = {
  entry: {
    app: './src/app.js',
    adminApp: './src/adminApp.js'
  }
};
#+end_src

*** Scenarios
**** Separate App and Vendor Entries
In webpack version < 4 it was common to add vendors as a separate entry point
to compile it as a separate file (in combination with the ~CommonsChunkPlugin~).

This is discouraged in webpack 4.  Instead, the =optimization.splitChunks=
option takes care of separating vendors and app modules and creating a separate
file.  Do not create an entry for vendors or other stuff that is not the
starting point of execution.

**** Multi-page Application
As a rule of thumb: Use exactly one entry point for each HTML document.

#+cindex:multi-page application
#+cindex:scenario, mutli-page application
#+caption:webpack.config.js Entry Multi-page App Scenario
#+name:webpack-config-entry-multi-page-app-scenario
#+begin_src js
module.exports = {
  entry: {
    pageOne: './src/pageOne/index.js',
    pageTwo: './src/pageTwo/index.js',
    pageThree: './src/pageThree/index.js'
  }
};
#+end_src

#+cindex:dependency graphs, multiple
We are telling {{{command(webpack)}}} that we would like 3 separate dependency
graphs.  In a multi-page application, the server is going to fetch a new HTML
document for you.  The page reloads this new document and assets are
redownloaded.  However, this gives us the unique opportunity to do multiple
things:

  #+cindex:@code{optimization.splitChunks}
  #+cindex:shared application code
  #+cindex:multi-page applications
- ~optimization.splitChunks~ :: use this to create bundles of shared
     application code between each page.  Multi-page applications that reuse a
     lot of code/modules between entry points can greatly benefit from these
     techniques, as the number of entry points increases.

** Output
#+cindex:@code{output} configuration
#+attr_texinfo: :indic code
- output ::

            =output= configuration options tells {{{command(webpack)}}} how to
            write the compiled files to disk.  While there can be multiple
            =entry= points, only one =output= configuration is specified.

            The minimum requirement for the output property in your webpack
            config is to set its value to an object including the following
            property:

            - =filename= : <'bundle.js'>

            #+begin_src js
            module.exports = {
                output: {
                    filename: 'bundle.js',
                }
            };
            #+end_src

            This configuration would output a single ~bundle.js~ file into the
            ~dist~ directory.


{{{heading(Multiple Entry Points)}}}

#+cindex:substitutions
#+cindex:chunk
#+cindex:CommonsChunkPlugin
If your configuration creates more than a single "chunk" (as with multiple
entry points or when using plugins like CommonsChunkPlugin), you should use
=substitutions= to ensure that each file has a unique name.

#+begin_src js
module.exports = {
  entry: {
    app: './src/app.js',
    search: './src/search.js'
  },
  output: {
    filename: '[name].js',
    path: __dirname + '/dist'
  }
};

// writes to disk: ./dist/app.js, ./dist/search.js
#+end_src

~[name]~ substitutes the entry names for the output names.

{{{heading(Advanced)}}}

Here's a more complicated example of using a CDN and hashes for assets:

#+begin_src js
module.exports = {
  //...
  output: {
    path: '/home/proj/cdn/assets/[hash]',
    publicPath: 'https://cdn.example.com/assets/[hash]/'
  }
};
#+end_src

In cases where the eventual =publicPath= of output files isn't known at compile
time, it can be left blank and set dynamically at runtime via the
~__webpack_public_path__~ variable in the entry point file:

#+begin_src js
__webpack_public_path__ = myRuntimePublicPath;

// rest of your application entry
#+end_src

** Loaders
#+cindex:loader
#+cindex:pre-process
#+cindex:tasks
Loaders are transformations that are applied on the source code of a module.
They allow you to pre-process files as you import or “load” them.  Thus,
loaders are kind of like “tasks” in other build tools and provide a powerful
way to handle front-end build steps.  Loaders can transform files from a
different language (like TypeScript) to JavaScript or inline images as data
URLs.  Loaders even allow you to do things like import CSS files directly from
your JavaScript modules!

{{{heading(Install Loaders)}}}

#+cindex:install loader
For example, you can use loaders to tell webpack to load a CSS file or to
convert TypeScript to JavaScript.  To do this, you would start by installing the
loaders you need:

#+begin_src sh
npm install --save-dev css-loader
npm install --save-dev ts-loader
#+end_src

And then instruct webpack to use the =css-loader= for every ~.css~ file and the
=ts-loader= for all ~.ts~ files:

#+name:webpack-config-loader-example
#+begin_src js
module.exports = {
  module: {
    rules: [
      { test: /\.css$/, use: 'css-loader' },
      { test: /\.ts$/, use: 'ts-loader' }
    ]
  }
};
#+end_src

*** Using Loaders

There are three ways to use loaders in your application:

- Configuration :: Specify them in your webpack.config.js file (recommended
                   way)

- Inline :: Specify them explicitly in each ~import~ statement

- CLI :: Specify them within a shell command


**** Configuration

#+cindex:@code{module.rules}
=module.rules= allows you to specify several loaders within your webpack
configuration.  This is a concise way to display loaders, and helps to maintain
clean code.  It also offers you a full overview of each respective loader.

Loaders are evaluated/executed from right to left (or from bottom to top).  In
the example below execution starts with =sass-loader=, continues with
=css-loader= and finally ends with =style-loader=.

#+name:webpack-config-loader-order
#+begin_src js
module.exports = {
  module: {
    rules: [
      {
        test: /\.css$/,
        use: [
          // style-loader
          { loader: 'style-loader' },
          // css-loader
          {
            loader: 'css-loader',
            options: {
              modules: true
            }
          },
          // sass-loader
          { loader: 'sass-loader' }
        ]
      }
    ]
  }
};
#+end_src

**** Inline
It's possible to specify loaders in an ~import~ statement, or any equivalent
"importing" method.  Separate loaders from the resource with =!=.  Each part is
resolved relative to the current directory.

: import Styles from 'style-loader!css-loader?modules!./styles.css';

It's possible to override any loaders, preLoaders and postLoaders from the
configuration by prefixing the inline import statement:

- Prefixing with =!= will disable all configured normal loaders

- Prefixing with =!!= will disable all configured loaders (preLoaders, loaders,
  postLoaders)

- Prefixing with =-!= will disable all configured preLoaders and loaders but
  not postLoaders


Options can be passed with a query parameter, e.g. =?key=value&foo=bar=, or a
JSON object, e.g. =?{"key":"value","foo":"bar"}=.

**** CLI
You can also use loaders through the CLI:

: webpack --module-bind jade-loader --module-bind 'css=style-loader!css-loader'

This uses the =jade-loader= for ~.jade~ files, and the =style-loader= and
=css-loader= for ~.css~ files.

*** Loader Features

#+cindex:chain loaders
- Loaders can be chained.  Each loader in the chain applies transformations to
  the processed resource.  A chain is executed in reverse order.  The first
  loader passes its result (resource with applied transformations) to the next
  one, and so forth.  Finally, webpack expects JavaScript to be returned by the
  last loader in the chain.

  #+cindex:synchronous
  #+cindex:asynchronous
- Loaders can be synchronous or asynchronous.

  #+cindex:Node.js
- Loaders run in Node.js and can do everything that’s possible there.

  #+cindex:options object
  #+cindex:query parameters
- Loaders can be configured with an options object (using query parameters to
  set options is still supported but has been deprecated).

  #+cindex:export
- Normal modules can export a loader in addition to the normal ~main~ via
  ~package.json~ with the =loader= field.

- Plugins can give loaders more features.

- Loaders can emit additional arbitrary files

*** Resolving Loaders
#+cindex:resolution, loader
#+cindex:loader resolution
#+cindex:module path
Loaders follow the standard module resolution.  In most cases it will be loaded
from the module path (think ~npm install~, ~node_modules~).

#+cindex:Node.js
A loader module is expected to export a function and be written in Node.js
compatible JavaScript.  They are most commonly managed with {{{command(npm)}}},
but you can also have custom loaders as files within your application.  By
convention, loaders are usually named ~xxx-loader~ (e.g. ~json-loader~).

** Plugins
#+cindex:plugin
Plugins serve the purpose of doing anything else that a loader cannot do.

A webpack plugin is a JavaScript object that has an ~apply~ method.  This
~apply~ method is called by the webpack compiler, giving access to the entire
compilation lifecycle.  Since plugins can take arguments/options, you must pass
a ~new~ instance to the =plugins= property in your webpack configuration.

*** Using Plugins
There are multiple ways to use plugins.

**** Configuration

#+name:webpack-config-plugins-example
#+begin_src js
const HtmlWebpackPlugin = require('html-webpack-plugin'); //installed via npm
const webpack = require('webpack'); //to access built-in plugins
const path = require('path');

module.exports = {
  entry: './path/to/my/entry/file.js',
  output: {
    filename: 'my-first-webpack.bundle.js',
    path: path.resolve(__dirname, 'dist')
  },
  module: {
    rules: [
      {
        test: /\.(js|jsx)$/,
        use: 'babel-loader'
      }
    ]
  },
  plugins: [
    new webpack.ProgressPlugin(),
    new HtmlWebpackPlugin({template: './src/index.html'})
  ]
};
#+end_src

**** Node.js
#+cindex:Node.js plugin
#+cindex:Node API
#+cindex:@code{plugins} property
When using the Node API, you can also pass plugins via the =plugins= property
in the configuration.

#+name:some-node-script-js
#+begin_src js
const webpack = require('webpack'); //to access webpack runtime
const configuration = require('./webpack.config.js');

let compiler = webpack(configuration);

new webpack.ProgressPlugin().apply(compiler);

compiler.run(function(err, stats) {
  // ...
});
#+end_src

** Configuration
- See: [[https://webpack.js.org/configuration/][Configuration section]] for all supported configuration options


#+cindex:configuration file
#+cindex:webpack configuration
Webpack's configuration file is a JavaScript file that exports a =webpack=
configuration.  This configuration is then processed by webpack based upon its
defined properties.

#+cindex:Node.js
#+cindex:CommonJS module
Because it's a standard Node.js =CommonJS= module, you can do the following:

- import other files via ~require(...)~

- use utilities on npm via ~require(...)~

- use JavaScript control flow expressions, e.g. the =?:= operator

- use constants or variables for often used values

- write and execute functions to generate a part of the configuration


The following practices should be avoided:

- Access CLI arguments, when using the webpack CLI (instead write your own CLI,
  or use {{{option(--env)}}})

- Export non-deterministic values (calling webpack twice should result in the
  same output files)

- Write long configurations (instead split the configuration into multiple
  files)


#+begin_cartouche
The most important part to take away from this document is that there are many
different ways to format and style your webpack configuration. The key is to
stick with something consistent that you and your team can understand and
maintain.
#+end_cartouche

{{{heading(Examples)}}}

{{{subheading(Simple Configuration)}}}

#+caption:~webpack.config.js~ Simple Configuration Example
#+name:webpack-config-js-simple-configuration
#+begin_src js
var path = require('path');

module.exports = {
  mode: 'development',
  entry: './foo.js',
  output: {
    path: path.resolve(__dirname, 'dist'),
    filename: 'foo.bundle.js'
  }
};
#+end_src

{{{subheading(Multiple Targets)}}}

Along with exporting a single configuration as an object, function or Promise,
you can export multiple configurations.  When running {{{command(webpack)}}},
all configurations are built.  However, if you pass a name to
{{{option(--config-name)}}} flag, {{{command(webpack)}}} will only build that
specific configuration.

#+cindex:AMD
#+cindex:CommonJS
For instance, this is useful for bundling a library for multiple targets such
as AMD and CommonJS:

#+caption:~webpack.config.js~ Multiple targets example
#+name:webpack-config-js-multiple-targets
#+begin_src js
module.exports = [{
  output: {
    filename: './dist-amd.js',
    libraryTarget: 'amd'
  },
  name: 'amd',
  entry: './app.js',
  mode: 'production',
}, {
  output: {
    filename: './dist-commonjs.js',
    libraryTarget: 'commonjs'
  },
  name: 'commonjs',
  entry: './app.js',
  mode: 'production',
}];
#+end_src

** Modules
{{{heading(WebPack Modules)}}}

#+cindex:Node.js
#+cindex:modular programming
#+cindex:module
#+cindex:modular JavaScript
Node.js has supported modular programming almost since its inception.  On the
web, however, support for modules has been slow to arrive.  Multiple tools
exist that support modular JavaScript on the web, with a variety of benefits
and limitations.  {{{command(webpack)}}} builds on lessons learned from these
systems and applies the concept of modules to any file in your project.

{{{subheading(WebPack Module Dependencies)}}}

In contrast to Node.js modules, {{{command(webpack)}}} modules can express
their dependencies in a variety of ways.  A few examples are:

#+cindex:ES2015
#+cindex:import statement
- An ES2015 import statement

  #+cindex:CommonJS
  #+cindex:@code{require()} statement
- A CommonJS ~require()~ statement

  #+cindex:AMD
  #+cindex:@code{define} statement
  #+cindex:@code{require} statement
- An AMD ~define~ and ~require~ statement

  #+cindex:@code{@@import} statement
  #+cindex:css/sass/less file
- An =@import= statement inside of a css/sass/less file.

  #+cindex:image url
  #+cindex:@code{url(...)}
  #+cindex:@code{<img src=...>}
- An image url in a stylesheet (~url(...)~) or html (~<img src=...>~) file.


{{{subheading(Supported Module Types)}}}

#+cindex:loaders
{{{command(webpack)}}} supports modules written in a variety of languages and
preprocessors, via loaders.  Loaders describe to {{{command(webpack)}}} how to
process non-JavaScript modules and include these dependencies into your
bundles.  The {{{command(webpack)}}} community has built loaders for a wide
variety of popular languages and language processors, including:

- CoffeeScript

- TypeScript

- ESNext (Babel)

- Sass

- Less

- Stylus


See [[https://webpack.js.org/loaders][Loaders]] for a full list of loaders.

Overall, {{{command(webpack)}}} provides a powerful and rich API for
customization that allows one to use {{{command(webpack)}}} for any stack,
while staying non-opinionated about your development, testing, and production
workflows.

** Module Resolution
#+cindex:resolver
A /resolver/ is a library which helps in locating a module by its absolute
path.  A module can be required as a dependency from another module as:

: import foo from 'path/to/module';
or
: require('path/to/module');

The dependency module can be from the application code or a third-party
library.  The resolver helps {{{command(webpack)}}} find the module code that
needs to be included in the bundle for every such =require/import= statement.
{{{command(webpack)}}} uses [[https://github.com/webpack/enhanced-resolve][enhanced-resolve]] to resolve file paths while
bundling modules.

*** Resolving Rules
Using [[https://github.com/webpack/enhanced-resolve][enhanced-resolve]], webpack can resolve three kinds of file paths:

{{{heading(Absolute paths)}}}

#+begin_src js
import '/home/me/file';

import 'C:\\Users\\me\\file';
#+end_src

Since we already have the absolute path to the file, no further resolution is
required.

{{{heading(Relative paths)}}}

#+begin_src js
import '../src/file1';
import './file2';
#+end_src

In this case, the directory of the resource file where the =import= or
=require= occurs is taken to be the =context= directory.  The relative path
specified in the =import/require= is joined to this =context= path to produce
the absolute path to the module.

{{{heading(Module paths)}}}

#+begin_src js
import 'module';
import 'module/lib/file';
#+end_src

Modules are searched for inside all directories specified in =resolve.modules=.
You can replace the original module path by an alternate path by creating an
alias for it using the =resolve.alias= configuration option.  Once the path is
resolved based on the above rule, the resolver checks to see if the path points
to a file or a directory.  If the path points to a file:

- If the path has a file extension, then the file is bundled straightaway.

- Otherwise, the file extension is resolved using the =resolve.extensions=
  option, which tells the resolver which extensions (eg - ~.js~, ~.jsx~) are
  acceptable for resolution.


If the path points to a folder, then the following steps are taken to find the
right file with the right extension:

- If the folder contains a =package.json= file, then fields specified in
  =resolve.mainFields= configuration option are looked up in order, and the
  first such field in ~package.json~ determines the file path.

- If there is no ~package.json~ or if the main fields do not return a valid
  path, file names specified in the ~resolve.mainFiles~ configuration option
  are looked for in order, to see if a matching filename exists in the
  =imported/required= directory.

- The file extension is then resolved in a similar way using the
  =resolve.extensions= option.


{{{command(webpack)}}} provides reasonable defaults for these options depending
on your build target.

*** Resolving Loaders
This follows the same rules as those specified for file resolution.  But the
=resolveLoader= configuration option can be used to have separate resolution
rules for loaders.

*** Caching
Every filesystem access is cached, so that multiple parallel or serial requests
to the same file occur faster.  In watch mode, only modified files are evicted
from the cache.  If watch mode is off, then the cache gets purged before every
compilation.

See [[https://webpack.js.org/configuration/resolve][Resolve API]] to learn more on the configuration options mentioned above.

** Dependency Graph
#+cindex:dependency
Any time one file /depends/ on another, webpack treats this as a dependency.
This allows webpack to take non-code assets, such as images or web fonts, and
also provide them as dependencies for your application.

When webpack processes your application, it starts from a list of modules
defined on the command line or in its config file.  Starting from these entry
points, webpack recursively builds a dependency graph that includes every
module your application needs, then bundles all of those modules into a small
number of bundles --- often, just one --- to be loaded by the browser.

#+cindex:HTTP/1.1
#+cindex:HTTP/2
#+cindex:Code Splitting
#+begin_cartouche
Bundling your application is especially powerful for HTTP/1.1 clients, as it
minimizes the number of times your app has to wait while the browser starts a
new request.  For HTTP/2, you can also use Code Splitting to achieve best
results.
#+end_cartouche

** Targets
#+cindex:target
#+cindex:deployment target
Because JavaScript can be written for both server and browser,
{{{command(webpack)}}} offers multiple /deployment targets/ that you can set in
your webpack configuration.

To set the =target= property, you simply set the =target= value in your webpack
config:

#+cindex:caption:Webpack Config Target Property
#+name:webpack.config.js-target-property
#+begin_src js
module.exports = {
  target: 'node'
};
#+end_src

In the example above, using node, {{{command(webpack)}}} will compile for usage
in a Node.js--like environment (uses Node.js require to load chunks and not
touch any built in modules like ~fs~ or ~path~).

Each /target/ has a variety of deployment/environment specific additions,
support to fit its needs.  See what [[https://webpack.js.org/configuration/target/][targets are available]].

*** Multiple Targets
Although {{{command(webpack)}}} does not support multiple strings being passed
into the =target= property, you can create an /isomorphic library/ by bundling
two separate configurations:

#+caption:Isomorphic Library for multiple targets
#+name:isomorphic-library
#+begin_src js
const path = require('path');
const serverConfig = {
  target: 'node',
  output: {
    path: path.resolve(__dirname, 'dist'),
    filename: 'lib.node.js'
  }
  //…
};

const clientConfig = {
  target: 'web', // <=== can be omitted as default is 'web'
  output: {
    path: path.resolve(__dirname, 'dist'),
    filename: 'lib.js'
  }
  //…
};

module.exports = [ serverConfig, clientConfig ];
#+end_src

The example above will create a ~lib.js~ and ~lib.node.js~ file in your ~dist~
folder.

*** Resources
As seen from the options above, there are multiple deployment targets that you
can choose from.  Below is a list of examples and resources that you can refer
to.

- [[https://github.com/TheLarkInn/compare-webpack-target-bundles][compare-webpack-target-bundles]] ::

     A great resource for testing and viewing different webpack targets. Also
     great for bug reporting.

- [[https://github.com/chentsulin/electron-react-boilerplate][Boilerplate of Electron-React Application]] ::

     A good example of a build process for electron's main process and renderer
     process.

** The Manifest
In a typical application or site built with {{{command(webpack)}}}, there are
three main types of code:

1. The source code you, and maybe your team, have written.

2. Any third-party library or "vendor" code your source is dependent on.

3. A webpack runtime and manifest that conducts the interaction of all modules.


{{{heading(Runtime)}}}

The runtime, along with the manifest data, is basically all the code
{{{command(webpack)}}} needs to connect your modularized application while it's
running in the browser.  It contains the loading and resolving logic needed to
connect your modules as they interact.  This includes connecting modules that
have already been loaded into the browser as well as logic to lazy-load the
ones that haven't.

{{{heading(Manifest)}}}

#+cindex:manifest
Once your application hits the browser in the form of ~index.html~ file, some
bundles and a variety of other assets required by your application must be
loaded and linked somehow.  That ~/src~ directory you meticulously laid out is
now bundled, minified and maybe even split into smaller chunks for lazy-loading
by webpack's optimization.  So how does {{{command(webpack)}}} manage the
interaction between all of your required modules?  This is where the manifest
data comes in...

As the compiler enters, resolves, and maps out your application, it keeps
detailed notes on all your modules.  This collection of data is called the
"Manifest," and it's what the runtime will use to resolve and load modules once
they've been bundled and shipped to the browser.  No matter which module syntax
you have chosen, those =import= or =require= statements have now become
=__webpack_require__= methods that point to module identifiers.  Using the data
in the manifest, the runtime will be able to find out where to retrieve the
modules behind the identifiers.

{{{heading(The Problem)}}}

So now you have a little bit of insight about how {{{command(webpack)}}} works
behind the scenes.  "But, how does this affect me?", you might ask.  The simple
answer is that most of the time it doesn't.  The runtime will do its thing,
utilizing the manifest, and everything will appear to just magically work once
your application hits the browser.  However, if you decide to improve the
performance of your projects by utilizing browser caching, this process will
all of a sudden become an important thing to understand.

By using content hashes within your bundle file names, you can indicate to the
browser when the content of a file has changed, thus invalidating the cache.
Once you start doing this though, you'll immediately notice some funny
behavior.  Certain hashes change even when their content apparently does not.
This is caused by the injection of the runtime and manifest, which changes
every build.

See [[https://webpack.js.org/guides/output-management/#the-manifest][the manifest section]] of our Output management guide to learn how to extract
the manifest, and read the guides below to learn more about the intricacies of
long term caching.

** Hot Module Replacement

** Module Bundler Resources
For a better understanding of the ideas behind module bundlers and how they
work under the hood, consult these resources:

- [[https://www.youtube.com/watch?v=UNMkLHzofQI][Manually Bundling an Application]]

- [[https://www.youtube.com/watch?v=Gc9-7PBqOC8][Live Coding a Simple Module Bundler]]

- [[https://github.com/ronami/minipack][Detailed Explanation of a Simple Module Bundler]]
* Gulp
- [[https://gulpjs.com][Gulp Home]]

{{{command(gulp)}}} is a toolkit for automating painful or time-consuming tasks
in your development workflow, so you can stop messing around and build
something.
* Grunt
- [[https://gruntjs.com][Gunt Home]]

The JavaScript task runner.

{{{heading(Why use a task runner?)}}}

In one word: automation.  The less work you have to do when performing
repetitive tasks like minification, compilation, unit testing, linting, etc,
the easier your job becomes.  After you've configured it through a Gruntfile, a
task runner can do most of that mundane work for you---and your team---with
basically zero effort.

{{{heading(Why use Grunt?)}}}

The Grunt ecosystem is huge and it's growing every day.  With literally
hundreds of plugins to choose from, you can use Grunt to automate just about
anything with a minimum of effort.  If someone hasn't already built what you
need, authoring and publishing your own Grunt plugin to npm is a breeze.  See
how to get started.

* Jest
“Jest is a delightful JavaScript Testing Framework with a focus on simplicit.”

- [[https://jestjs.io][Jest Home]]

- [[https://jestjs.io/docs/en/getting-started][Jest Docs]]

- [[https://jestjs.io/docs/en/api][Jest API]]

- [[https://jestjs.io/blog/][Jest Blog]]

It works with projects using: Babel, TypeScript, Node, React, Angular, Vue and
more!

{{{heading(Philosophy)}}}

#+cindex:JasvaScript test framework
Jest is a JavaScript testing framework designed to ensure correctness of any
JavaScript codebase.  It allows you to write tests with an approachable,
familiar and feature-rich API that gives you results quickly.

Jest is well-documented, requires little configuration and can be extended to
match your requirements.

{{{heading(Features)}}}

- zero config :: Jest aims to work out of the box, config free, on most
                 JavaScript projects.

- snapshots :: Make tests which keep track of large objects with
               ease. Snapshots live either alongside your tests, or embedded
               inline.

- isolated :: Tests are parallelized by running them in their own processes to
              maximize performance.

- great api :: From ~it~ to ~expect~ --- Jest has the entire toolkit in one
               place.  Well documented, well maintained, well good.

- FAST AND SAFE :: By ensuring your tests have unique global state, Jest can
                   reliably run tests in parallel. To make things quick, Jest
                   runs previously failed tests first and re-organizes runs
                   based on how long test files take.

- Code Coverage :: Generate code coverage by adding the flag --coverage. No
                   additional setup needed. Jest can collect code coverage
                   information from entire projects, including untested files.

- Easy Mocking :: Jest uses a custom resolver for imports in your tests making
                  it simple to mock any object outside of your test’s
                  scope. You can use mocked imports with the rich Mock
                  Functions API to spy on function calls with readable test
                  syntax.

- Great Exceptions :: Tests fail, when they do Jest provides rich context why,
     here’s some examples:

** Jest Documentation

#+cindex:Jest documentation
*** Jest Getting Started

#+cindex:Jest getting started
#+cindex:getting started, Jest
Jest documentation uses ~yarn~ commands.

#+cindex:install Jest
{{{heading(Install Jest)}}}

: yarn add --dev jest

{{{heading(Simple Tests)}}}

#+cindex:Jest simple tests
#+cindex:simple tests, Jest
{{{subheading(Test a function that adds two numbers)}}}

#+caption: Function to add two numbers
#+name:sum.js
#+begin_src js -n
function sum(a, b) {
  return a + b;
}
module.exports = sum;
#+end_src

Create a file named ~sum.test.js~.  This will contain our actual test:

#+cindex:.test.js
#+caption:sum.test.js to test sum.js
#+name:sum.test.js
#+begin_src js -n
const sum = require('./sum');

test('adds 1 + 2 to equal 3', () => {
  expect(sum(1, 2)).toBe(3);
});
#+end_src

#+cindex:@code{expect}
#+cindex:@code{toBe}
#+cindex:exact equality
This test uses ~expect~ and ~toBe~ to test that two values are exactly
identical.  To learn about the other things that Jest can test, see [[https://jestjs.io/docs/en/using-matchers][Using
Matchers]].

{{{subheading(Update ~package.json~)}}}

#+cindex:test script, Jest
#+caption:Add test script to package.json
#+name:package.json-test-script
#+begin_src json
{
  "scripts": {
    "test": "jest"
  }
}
#+end_src

{{{subheading(Use Yarn to test)}}}

To test:

#+cindex:yarn test
#+cindex:test, yarn
: yarn test

{{{noindent}}}and Jest will print this message:

#+begin_example
PASS  ./sum.test.js
✓ adds 1 + 2 to equal 3 (5ms)
#+end_example

*** Run Jest from the Command Line
#+cindex:Jest from command line
#+cindex:command line, Jest
You can run Jest directly from the CLI (if it's globally available in your
PATH, e.g. by ~yarn global add jest~) with a variety of useful options.

Here's how to run Jest on files matching ~my-test~, using ~config.json~ as a
configuration file and display a native OS notification after the run:

: jest my-test --notify --config=config.json

#+cindex:CLI option, Jest
If you'd like to learn more about running jest through the command line, take a
look at the [[https://jestjs.io/docs/en/cli][Jest CLI Options]] page.

*** Additional Configuration

{{{heading(Generate a basic configuration file)}}}

#+cindex:Jest init
#+cindex:init, Jest
Based on your project, Jest will ask you a few questions and will create a
basic configuration file with a short description for each option:

: jest --init

**** Configure Jest for Babel

#+cindex:Jest, Babel
#+cindex:Babel, Jest
To use [[http://babeljs.io/][Babel]], install required dependencies via ~yarn~:

: yarn add --dev babel-jest @babel/core @babel/preset-env

{{{subheading(Configure Babel)}}}

#+cindex:configure Babel for Jest
Configure Babel to target your current version of Node by creating a
~babel.config.js~ file in the root of your project:

#+caption: Babel Config file
#+name:babel.config.js
#+begin_src js -n
// babel.config.js
module.exports = {
  presets: [
    [
      '@babel/preset-env',
      {
        targets: {
          node: 'current',
        },
      },
    ],
  ],
};
#+end_src

The ideal configuration for Babel will depend on your project.  See [[https://babeljs.io/docs/en/][Babel's
docs]] for more details.

{{{subheading(Configure Babel to use Jest)}}}

#+cindex:@code{process.env.NODE_ENV}
#+cindex:@code{isTest} function
Jest will set =process.env.NODE_ENV= to 'test' if it's not set to something
else.  You can use that in your configuration to conditionally setup only the
compilation needed for Jest, e.g.:

#+caption: Make ~babel.config.js~ Jest-aware
#+name:babel.config.js-jest-aware
#+begin_src js -n
// babel.config.js
module.exports = api => {
  const isTest = api.env('test');
  // You can use isTest to determine what presets and plugins to use.

  return {
    // ...
  };
};
#+end_src

**** Configure Jest for Webpack
#+cindex:Jest, Webpack
#+cindex:Webpack, Jest
Jest can be used in projects that use [[https://webpack.github.io/][webpack]] to manage assets, styles, and
compilation.  ~webpack~ does offer some unique challenges over other tools.
Refer to the [[https://jestjs.io/docs/en/webpack][webpack guide]] to get started.

**** Configure Jest for TypeScript
#+cindex:TypeScript, Jest
#+cindex:Jest, TypeScript
#+cindex:TypeScript, Babel, Jest
#+cindex:Jest, TypeScript, Babel
#+cindex:@code{@@babel/present-typescript}
Jest supports TypeScript, via Babel.  First make sure you followed the
instructions on using Babel above.  Next install the =@babel/preset-typescript=
via ~yarn~:

: yarn add --dev @babel/preset-typescript

#+cindex:@code{babel.config.js}
Then add =@babel/preset-typescript= to the list of presets in your
~babel.config.js~.

#+caption: Add TypeScript support to babel.config.js
#+name:babel.config.js-for-typescript
#+begin_src js -n
// babel.config.js
module.exports = {
  presets: [
    ['@babel/preset-env', {targets: {node: 'current'}}],
+    '@babel/preset-typescript',
  ],
};
#+end_src

#+cindex:@code{ts-jest}
Because TypeScript support in Babel is just transpilation, Jest will not
type-check your tests as they are ran.  If you want that, you can use [[https://github.com/kulshekhar/ts-jest][ts-jest]].

*** Jest Matchers
#+cindex:matchers, Jest
Jest uses "matchers" to let you test values in different ways.  This document
will introduce some commonly used matchers.

**** Common Matchers
The simplest way to test a value is with exact equality.

#+caption:Testing for exact equality
#+name:test-for-exact-equality
#+begin_src js -n
test('two plus two is four', () => {
  expect(2 + 2).toBe(4);
});
#+end_src

In this code, ~expect(2 + 2)~ returns an "expectation" object.  You typically
won't do much with these expectation objects except call matchers on them.  In
this code, ~.toBe(4)~ is the matcher.  When Jest runs, it tracks all the
failing matchers so that it can print out nice error messages for you.

~toBe~ uses ~Object.is~ to test exact equality.  If you want to check the value
of an object, use ~toEqual~ instead:

#+caption:Testing the value of an object
#+name:test-value-of-object
#+begin_src js -n
test('object assignment', () => {
  const data = {one: 1};
  data['two'] = 2;
  expect(data).toEqual({one: 1, two: 2});
});
#+end_src

~toEqual~ recursively checks every field of an object or array.

You can also test for the opposite of a matcher:

#+caption:Testing the opposite of a matcher
#+name:test-the-opposite
#+begin_src js -n
test('adding positive numbers is not zero', () => {
  for (let a = 1; a < 10; a++) {
    for (let b = 1; b < 10; b++) {
      expect(a + b).not.toBe(0);
    }
  }
});
#+end_src

**** Truthiness
In tests you sometimes need to distinguish between =undefined=, =null=, and
=false=, but you sometimes do not want to treat these differently.  Jest
contains helpers that let you be explicit about what you want.

- =toBeNull= matches only =null=

- =toBeUndefined= matches only =undefined=

- =toBeDefined= is the opposite of =toBeUndefined=

- =toBeTruthy= matches anything that an =if= statement treats as =true=

- =toBeFalsy= matches anything that an =if= statement treats as =false=


#+caption:Testing truthiness
#+name:testing-truthiness
#+begin_src js -n
test('null', () => {
  const n = null;
  expect(n).toBeNull();
  expect(n).toBeDefined();
  expect(n).not.toBeUndefined();
  expect(n).not.toBeTruthy();
  expect(n).toBeFalsy();
});

test('zero', () => {
  const z = 0;
  expect(z).not.toBeNull();
  expect(z).toBeDefined();
  expect(z).not.toBeUndefined();
  expect(z).not.toBeTruthy();
  expect(z).toBeFalsy();
});
#+end_src

You should use the matcher that most precisely corresponds to what you want
your code to be doing.

**** Numbers
Most ways of comparing numbers have matcher equivalents.

#+caption:Testing Numbers
#+name:testing-numbers
#+begin_src js -n
test('two plus two', () => {
  const value = 2 + 2;
  expect(value).toBeGreaterThan(3);
  expect(value).toBeGreaterThanOrEqual(3.5);
  expect(value).toBeLessThan(5);
  expect(value).toBeLessThanOrEqual(4.5);

  // toBe and toEqual are equivalent for numbers
  expect(value).toBe(4);
  expect(value).toEqual(4);
});
#+end_src

{{{subheading(Testing Floating Point Numbers)}}}

For floating point equality, use ~toBeCloseTo~ instead of ~toEqual~, because
you don't want a test to depend on a tiny rounding error.

#+caption:Testing Floating Point Numbers
#+name:test-floating-point-numbers
#+begin_src js -n
test('adding floating point numbers', () => {
  const value = 0.1 + 0.2;
  //expect(value).toBe(0.3);           This won't work because of rounding error
  expect(value).toBeCloseTo(0.3); // This works.
});
#+end_src

**** Strings
You can check strings against regular expressions with ~toMatch~:

#+caption:Testing Strings
#+name:test-strings
#+begin_src js -n
test('there is no I in team', () => {
  expect('team').not.toMatch(/I/);
});

test('but there is a "stop" in Christoph', () => {
  expect('Christoph').toMatch(/stop/);
});
#+end_src

**** Arrays and Iterables
You can check if an array or iterable contains a particular item using
~toContain~:

#+caption:Testing Arrays and Iterables
#+name:test-arrays-and-iterables
#+begin_src js -n
const shoppingList = [
  'diapers',
  'kleenex',
  'trash bags',
  'paper towels',
  'beer',
];

test('the shopping list has beer on it', () => {
  expect(shoppingList).toContain('beer');
  expect(new Set(shoppingList)).toContain('beer');
});
#+end_src

**** Exceptions
If you want to test that a particular function throws an error when it's
called, use ~toThrow~.

#+caption:Testing Exceptions
#+name:test-exceptions
#+begin_src js -n
function compileAndroidCode() {
  throw new Error('you are using the wrong JDK');
}

test('compiling android goes as expected', () => {
  expect(compileAndroidCode).toThrow();
  expect(compileAndroidCode).toThrow(Error);

  // You can also use the exact error message or a regexp
  expect(compileAndroidCode).toThrow('you are using the wrong JDK');
  expect(compileAndroidCode).toThrow(/JDK/);
});
#+end_src

*** Testing Asynchronous Code
#+cindex:asynchronous code, Jest
It's common in JavaScript for code to run asynchronously.  When you have code
that runs asynchronously, Jest needs to know when the code it is testing has
completed, before it can move on to another test.  Jest has several ways to
handle this.

**** Callbacks
The most common asynchronous pattern is callbacks.

For example, let's say that you have a ~fetchData(callback)~ function that
fetches some data and calls ~callback(data)~ when it is complete.  You want to
test that this returned data is just the string 'peanut butter'.

Instead of putting the test in a function with an empty argument, use a single
argument called =done=.  Jest will wait until the =done= callback is called
before finishing the test.

#+caption:Demonstrating asynchronouse testing with =done=
#+name:test-asynchronous-code-with-done
#+begin_src js -n
// Don't do this!
test('the data is peanut butter', () => {
  function callback(data) {
    expect(data).toBe('peanut butter');
  }

  fetchData(callback);
});

// Do this!
test('the data is peanut butter', done => {
  function callback(data) {
    expect(data).toBe('peanut butter');
    done();
  }

  fetchData(callback);
});
#+end_src

If ~done()~ is never called, the test will fail, which is what you want to
happen.

**** Promises
#+cindex:Promises, Jest
If your code uses promises, there is a simpler way to handle asynchronous
tests.  Just return a promise from your test, and Jest will wait for that
promise to resolve.  If the promise is rejected, the test will automatically
fail.

For example, let's say that ~fetchData~, instead of using a callback, returns a
promise that is supposed to resolve to the string 'peanut butter'.  We could
test it with:

#+caption:Testing asynchronous code with promises
#+name:test-asynchronous-code-with-promises
#+begin_src js -n
test('the data is peanut butter', () => {
  return fetchData().then(data => {
    expect(data).toBe('peanut butter');
  });
});
#+end_src

Be sure to return the promise --- if you omit this ~return~ statement, your
test will complete before the promise returned from ~fetchData~ resolves and
~then()~ has a chance to execute the callback.

If you expect a promise to be rejected use the ~.catch~ method.  Make sure to
add ~expect.assertions~ to verify that a certain number of assertions are
called.  Otherwise a fulfilled promise would not fail the test.

#+caption:Testing asynchronous code with promises and catch
#+name:test-asynchronous-code-with-promises-and-catch
#+begin_src js -n
test('the fetch fails with an error', () => {
  expect.assertions(1);
  return fetchData().catch(e => expect(e).toMatch('error'));
});
#+end_src

{{{heading(Using ~.resolves~ and ~.rejects~)}}}

You can also use the ~.resolves~ matcher in your =expect= statement, and Jest
will wait for that promise to resolve.  If the promise is rejected, the test
will automatically fail.

#+caption:Testing asynchronous code with ~.resolves~
#+name:test-asynchronous-code-with-.resolves
#+begin_src js -n
test('the data is peanut butter', () => {
  return expect(fetchData()).resolves.toBe('peanut butter');
});
#+end_src

Be sure to return the assertion---if you omit this ~return~ statement, your
test will complete before the promise returned from ~fetchData~ is resolved and
~then()~ has a chance to execute the callback.

If you expect a promise to be rejected use the ~.rejects~ matcher.  It works
analogically to the ~.resolves~ matcher.  If the promise is fulfilled, the test
will automatically fail.

#+caption:Testing asynchronous code using ~.rejects~
#+name:test-asynchronous-code-using-.rejects
#+begin_src js -n
test('the fetch fails with an error', () => {
  return expect(fetchData()).rejects.toMatch('error');
});
#+end_src

**** Async-Await
#+cindex:async-await, Jest
Alternatively, you can use =async= and =await= in your tests.  To write an
=async= test, just use the =async= keyword in front of the function passed to
test.  For example, the same ~fetchData~ scenario can be tested with:

#+caption:Testing asynchronous code using async/await
#+name:test-asynchronous-code-using-async-await
#+begin_src js -n
test('the data is peanut butter', async () => {
  const data = await fetchData();
  expect(data).toBe('peanut butter');
});

test('the fetch fails with an error', async () => {
  expect.assertions(1);
  try {
    await fetchData();
  } catch (e) {
    expect(e).toMatch('error');
  }
});
#+end_src

You can combine =async= and =await= with ~.resolves~ or ~.rejects~.

#+caption:Testing asynchronous code using both async/await and .resolves/.rejects
#+name:test-asynchronous-code-using-both
#+begin_src js -n
test('the data is peanut butter', async () => {
  await expect(fetchData()).resolves.toBe('peanut butter');
});

test('the fetch fails with an error', async () => {
  await expect(fetchData()).rejects.toThrow('error');
});
#+end_src

In these cases, =async= and =await= are effectively just syntactic sugar for
the same logic as the promises example uses.

None of these forms is particularly superior to the others, and you can mix and
match them across a codebase or even in a single file.  It just depends on
which style makes your tests simpler.

*** Setup and Teardown
#+cindex:Jest setup, teardown
#+cindex:setup
#+cindex:teardown
Often while writing tests you have some setup work that needs to happen before
tests run, and you have some finishing work that needs to happen after tests
run.  Jest provides helper functions to handle this.

**** Repeating Setup For Many Tests
If you have some work you need to do repeatedly for many tests, you can use
~beforeEach~ and ~afterEach~.

For example, let's say that several tests interact with a database of
cities. You have a method ~initializeCityDatabase()~ that must be called before
each of these tests, and a method ~clearCityDatabase()~ that must be called
after each of these tests.  You can do this with:

#+caption:Setting up before many tests
#+name:setting-up-beforfe-many-tests
#+begin_src js -n
beforeEach(() => {
  initializeCityDatabase();
});

afterEach(() => {
  clearCityDatabase();
});

test('city database has Vienna', () => {
  expect(isCity('Vienna')).toBeTruthy();
});

test('city database has San Juan', () => {
  expect(isCity('San Juan')).toBeTruthy();
});
#+end_src

~beforeEach~ and ~afterEach~ can handle asynchronous code in the same ways that
tests can handle asynchronous code --- they can either take a =done= parameter
or return a promise.  For example, if ~initializeCityDatabase()~ returned a
promise that resolved when the database was initialized, we would want to
return that promise:

#+caption:Asynchronous setting up
#+name:asynchronous-setting-up
#+begin_src js -n
beforeEach(() => {
  return initializeCityDatabase();
});
#+end_src

**** One-Time Setup
In some cases, you only need to do setup once, at the beginning of a file.
This can be especially bothersome when the setup is asynchronous, so you can't
just do it inline.  Jest provides ~beforeAll~ and ~afterAll~ to handle this
situation.

For example, if both ~initializeCityDatabase~ and ~clearCityDatabase~ returned
promises, and the city database could be reused between tests, we could change
our test code to:

#+caption:One-Time setup
#+name:one-time-setup
#+begin_src js -n
beforeAll(() => {
  return initializeCityDatabase();
});

afterAll(() => {
  return clearCityDatabase();
});

test('city database has Vienna', () => {
  expect(isCity('Vienna')).toBeTruthy();
});

test('city database has San Juan', () => {
  expect(isCity('San Juan')).toBeTruthy();
});
#+end_src

**** Scoping
By default, the =before= and =after= blocks apply to every test in a file.  You
can also group tests together using a =describe= block.  When they are inside a
=describe= block, the =before= and =after= blocks only apply to the tests
within that =describe= block.

For example, let's say we had not just a city database, but also a food
database.  We could do different setup for different tests:

#+caption:Example of scoping different test blocks
#+name:scoping-example
#+begin_src js -n
// Applies to all tests in this file
beforeEach(() => {
  return initializeCityDatabase();
});

test('city database has Vienna', () => {
  expect(isCity('Vienna')).toBeTruthy();
});

test('city database has San Juan', () => {
  expect(isCity('San Juan')).toBeTruthy();
});

describe('matching cities to foods', () => {
  // Applies only to tests in this describe block
  beforeEach(() => {
    return initializeFoodDatabase();
  });

  test('Vienna <3 sausage', () => {
    expect(isValidCityFoodPair('Vienna', 'Wiener Schnitzel')).toBe(true);
  });

  test('San Juan <3 plantains', () => {
    expect(isValidCityFoodPair('San Juan', 'Mofongo')).toBe(true);
  });
});
#+end_src

Note that the top-level =beforeEach= is executed before the =beforeEach= inside
the =describe= block.  It may help to illustrate the order of execution of all
hooks.

#+caption:Order of execution
#+name:order-of-execution
#+begin_example
beforeAll(() => console.log('1 - beforeAll'));
afterAll(() => console.log('1 - afterAll'));
beforeEach(() => console.log('1 - beforeEach'));
afterEach(() => console.log('1 - afterEach'));
test('', () => console.log('1 - test'));
describe('Scoped / Nested block', () => {
  beforeAll(() => console.log('2 - beforeAll'));
  afterAll(() => console.log('2 - afterAll'));
  beforeEach(() => console.log('2 - beforeEach'));
  afterEach(() => console.log('2 - afterEach'));
  test('', () => console.log('2 - test'));
});

// 1 - beforeAll
// 1 - beforeEach
// 1 - test
// 1 - afterEach
// 2 - beforeAll
// 1 - beforeEach
// 2 - beforeEach
// 2 - test
// 2 - afterEach
// 1 - afterEach
// 2 - afterAll
// 1 - afterAll
#+end_example

**** Order of execution of describe and test blocks
Jest executes all =describe= handlers in a test file before it executes any of
the actual tests.  This is another reason to do setup and teardown inside
=before*= and =after*= handlers rather than inside the =describe= blocks.  Once
the =describe= blocks are complete, by default Jest runs all the tests serially
in the order they were encountered in the collection phase, waiting for each to
finish and be tidied up before moving on.

Consider the following illustrative test file and output:

#+caption:Demonstration of order of execution
#+name:demonstrate-order-of-executiuon
#+begin_src js -n
describe('outer', () => {
  console.log('describe outer-a');

  describe('describe inner 1', () => {
    console.log('describe inner 1');
    test('test 1', () => {
      console.log('test for describe inner 1');
      expect(true).toEqual(true);
    });
  });

  console.log('describe outer-b');

  test('test 1', () => {
    console.log('test for describe outer');
    expect(true).toEqual(true);
  });

  describe('describe inner 2', () => {
    console.log('describe inner 2');
    test('test for describe inner 2', () => {
      console.log('test for describe inner 2');
      expect(false).toEqual(false);
    });
  });

  console.log('describe outer-c');
});

// describe outer-a
// describe inner 1
// describe outer-b
// describe inner 2
// describe outer-c
// test for describe inner 1
// test for describe outer
// test for describe inner 2
#+end_src

**** General Advice
If a test is failing, one of the first things to check should be whether the
test is failing when it's the only test that runs.  In Jest it's simple to run
only one test --- just temporarily change that test command to a ~test.only~:

#+caption:Run only one test
#+name:run-test-only
#+begin_src js -n
test.only('this will be the only test that runs', () => {
  expect(true).toBe(false);
});

test('this test will not run', () => {
  expect('A').toBe('A');
});
#+end_src

If you have a test that often fails when it's run as part of a larger suite,
but doesn't fail when you run it alone, it's a good bet that something from a
different test is interfering with this one.  You can often fix this by
clearing some shared state with =beforeEach=.  If you're not sure whether some
shared state is being modified, you can also try a =beforeEach= that just logs
data.

*** Mock Functions
#+cindex:mocking, Jest
Mock functions make it easy to test the links between code by erasing the
actual implementation of a function, capturing calls to the function (and the
parameters passed in those calls), capturing instances of constructor functions
when instantiated with =new=, and allowing test-time configuration of return
values.

There are two ways to mock functions: Either by creating a mock function to use
in test code, or writing a manual mock to override a module dependency.

**** Using a mock function
Let's imagine we're testing an implementation of a function ~forEach~, which
invokes a callback for each item in a supplied array.

#+caption:ForEach implementation
#+name:foreach-implementation
#+begin_src js -n
function forEach(items, callback) {
  for (let index = 0; index < items.length; index++) {
    callback(items[index]);
  }
}
#+end_src

To test this function, we can use a mock function, and inspect the mock's state
to ensure the callback is invoked as expected.

#+caption:Test forEach function with a moch function
#+name:test-foreach-with-mock-function
#+begin_src js -n
const mockCallback = jest.fn(x => 42 + x);
forEach([0, 1], mockCallback);

// The mock function is called twice
expect(mockCallback.mock.calls.length).toBe(2);

// The first argument of the first call to the function was 0
expect(mockCallback.mock.calls[0][0]).toBe(0);

// The first argument of the second call to the function was 1
expect(mockCallback.mock.calls[1][0]).toBe(1);

// The return value of the first call to the function was 42
expect(mockCallback.mock.results[0].value).toBe(42);
#+end_src

**** .mock property
All mock functions have this special ~.mock~ property, which is where data
about how the function has been called and what the function returned is kept.
The ~.mock~ property also tracks the value of this for each call, so it is
possible to inspect this as well:

#+caption:Mock test using .mock property
#+name:mock-test-using-.mock-property
#+begin_src js -n
const myMock = jest.fn();

const a = new myMock();
const b = {};
const bound = myMock.bind(b);
bound();

console.log(myMock.mock.instances);
// > [ <a>, <b> ]
#+end_src

These mock members are very useful in tests to assert how these functions get
called, instantiated, or what they returned:

#+caption:Mock members
#+name:mock-members
#+begin_src js -n
// The function was called exactly once
expect(someMockFunction.mock.calls.length).toBe(1);

// The first arg of the first call to the function was 'first arg'
expect(someMockFunction.mock.calls[0][0]).toBe('first arg');

// The second arg of the first call to the function was 'second arg'
expect(someMockFunction.mock.calls[0][1]).toBe('second arg');

// The return value of the first call to the function was 'return value'
expect(someMockFunction.mock.results[0].value).toBe('return value');

// This function was instantiated exactly twice
expect(someMockFunction.mock.instances.length).toBe(2);

// The object returned by the first instantiation of this function
// had a `name` property whose value was set to 'test'
expect(someMockFunction.mock.instances[0].name).toEqual('test');
#+end_src

**** Mock Return Values
Mock functions can also be used to inject test values into your code during a
test:

#+caption:Using mock functions to inject test values
#+name:inject-test-values
#+begin_src js -n
const myMock = jest.fn();
console.log(myMock());
// > undefined

myMock
  .mockReturnValueOnce(10)
  .mockReturnValueOnce('x')
  .mockReturnValue(true);

console.log(myMock(), myMock(), myMock(), myMock());
// > 10, 'x', true, true
#+end_src

Mock functions are also very effective in code that uses a functional
continuation-passing style.  Code written in this style helps avoid the need
for complicated stubs that recreate the behavior of the real component they're
standing in for, in favor of injecting values directly into the test right
before they're used.

#+caption:Using mock functions for continuation-passing
#+name:mock-functions-continuation-style
#+begin_src js -n
const filterTestFn = jest.fn();

// Make the mock return `true` for the first call,
// and `false` for the second call
filterTestFn.mockReturnValueOnce(true).mockReturnValueOnce(false);

const result = [11, 12].filter(filterTestFn);

console.log(result);
// > [11]
console.log(filterTestFn.mock.calls);
// > [ [11], [12] ]
#+end_src

Most real-world examples actually involve getting ahold of a mock function on a
dependent component and configuring that, but the technique is the same.  In
these cases, try to avoid the temptation to implement logic inside of any
function that's not directly being tested.

**** Mocking Modules
Suppose we have a class that fetches users from our API.  The class uses
~axios~ to call the API then returns the data attribute which contains all the
users:

#+caption:A module using axios
#+name:module-using-axios
#+begin_src js -n
// users.js
import axios from 'axios';

class Users {
  static all() {
    return axios.get('/users.json').then(resp => resp.data);
  }
}

export default Users;
#+end_src

Now, in order to test this method without actually hitting the API (and thus
creating slow and fragile tests), we can use the ~jest.mock(...)~ function to
automatically mock the ~axios~ module.

Once we mock the module we can provide a ~mockResolvedValue~ for ~.get~ that
returns the data we want our test to assert against.  In effect, we are saying
that we want ~axios.get('/users.json')~ to return a fake response.

#+caption:Mocking a module
#+name:mock-a-module
#+begin_src js -n
// users.test.js
import axios from 'axios';
import Users from './users';

jest.mock('axios');

test('should fetch users', () => {
  const users = [{name: 'Bob'}];
  const resp = {data: users};
  axios.get.mockResolvedValue(resp);

  // or you could use the following depending on your use case:
  // axios.get.mockImplementation(() => Promise.resolve(resp))

  return Users.all().then(data => expect(data).toEqual(users));
});
#+end_src

**** Mock Implementations
Still, there are cases where it's useful to go beyond the ability to specify
return values and full-on replace the implementation of a mock function.  This
can be done with ~jest.fn~ or the ~mockImplementationOnce~ method on mock
functions.

...

**** Mock Names
You can optionally provide a name for your mock functions, which will be
displayed instead of "jest.fn()" in test error output.  Use this if you want to
be able to quickly identify the mock function reporting an error in your test
output.

#+caption:Mock names
#+name:moch-names
#+begin_src js -n
const myMockFn = jest
  .fn()
  .mockReturnValue('default')
  .mockImplementation(scalar => 42 + scalar)
  .mockName('add42');
#+end_src

**** Custom Matchers
Finally, in order to make it simpler to assert how mock functions have been
called, we've added some custom matcher functions for you:

#+caption:Custom matcher functions
#+name:custom-matcher-functions
#+begin_src js -n
// The mock function was called at least once
expect(mockFunc).toBeCalled();

// The mock function was called at least once with the specified args
expect(mockFunc).toBeCalledWith(arg1, arg2);

// The last call to the mock function was called with the specified args
expect(mockFunc).lastCalledWith(arg1, arg2);

// All calls and the name of the mock is written as a snapshot
expect(mockFunc).toMatchSnapshot();
#+end_src

These matchers are really just sugar for common forms of inspecting the ~.mock~
property.  You can always do this manually yourself if that's more to your
taste or if you need to do something more specific:

#+caption:Inspecting .mock property manually
#+name:inspect-mock-property-manually
#+begin_src js -n
// The mock function was called at least once
expect(mockFunc.mock.calls.length).toBeGreaterThan(0);

// The mock function was called at least once with the specified args
expect(mockFunc.mock.calls).toContainEqual([arg1, arg2]);

// The last call to the mock function was called with the specified args
expect(mockFunc.mock.calls[mockFunc.mock.calls.length - 1]).toEqual([
  arg1,
  arg2,
]);

// The first arg of the last call to the mock function was `42`
// (note that there is no sugar helper for this specific of an assertion)
expect(mockFunc.mock.calls[mockFunc.mock.calls.length - 1][0]).toBe(42);

// A snapshot will check that a mock was invoked the same number of times,
// in the same order, with the same arguments. It will also assert on the name.
expect(mockFunc.mock.calls).toEqual([[arg1, arg2]]);
expect(mockFunc.getMockName()).toBe('a mock name');
#+end_src

*** Jest Platform
You can cherry pick specific features of Jest and use them as standalone
packages. Here's a list of the available packages:

**** jest-changed-files

**** jest-diff

**** jest-docblock

**** jest-get-type

**** jest-validate

**** jest-worker

**** pretty-format

** Jest Guides

** Jest Framework Guides

** Jest API Reference
* Mocha
- https://mochajs.org
- https://github.com/mochajs/mocha


“a javascript test framework for node.js & the browser”

#+cindex:Mocha test framework
Mocha is a JavaScript test framework running on Node.js and in the browser.
Mocha tests run serially, allowing for flexible and accurate reporting, while
mapping uncaught exceptions to the correct test cases.  Mocha is an independent
open-source project, maintained exclusively by volunteers.

** Mocha Installation
Install as a development dependency for a project:
: $ npm install --save-dev mocha

** Mocha Getting Started
#+cindex:@code{test.js}
Create a test file named ~test/test.js~:

#+name:mocha-test.js
#+begin_src js
var assert = require('assert');
describe('Array', function() {
  describe('#indexOf()', function() {
    it('should return -1 when the value is not present', function() {
      assert.equal([1, 2, 3].indexOf(4), -1);
    });
  });
});
#+end_src

{{{heading(From the command-line)}}}

: $ ./node_modules/mocha/bin/mocha

{{{noindent}}}with output:

#+begin_example
Array
    #indexOf()
      ✓ should return -1 when the value is not present


1 passing (9ms)
#+end_example

{{{heading(Set up a test script in ‘package.json’)}}}

#+begin_src js
"scripts": {
  "test": "mocha"
}
#+end_src

{{{noindent}}}and run with:

: $ npm test

** Mocha Assertion Libraries
#+cindex:assertion libraries
Mocha allows you to use any assertion library you wish---generally, if it
throws an =Error=, it will work!  This means you can use libraries such as:

- [[https://www.chaijs.com/][chai]]

- [[https://github.com/shouldjs/should.js][should.js]]

- [[https://github.com/LearnBoost/expect.js][expect.js]]

- [[https://github.com/visionmedia/better-assert][better-assert]]

- [[https://unexpected.js.org/][unexpected]]

** Mocha and Testing Asynchronous Code
Simply invoke the callback when your test is complete.  By adding a callback
(usually named ~done~) to ~it()~, Mocha will know that it should wait for this
function to be called to complete the test.  This callback accepts both an
=Error= instance (or subclass thereof) or a =falsy= value; anything else will
cause a failed test.

#+name:Mocha-asynchronous-test
#+begin_src js -n
describe('User', function() {
  describe('#save()', function() {
    it('should save without error', function(done) {
      var user = new User('Luna');
      user.save(function(err) {
        if (err) done(err); // <==== Error
        else done();        // <==== calling done()
      });
    });
  });
});
#+end_src

Alternatively, just use the ~done()~ callback directly (which will handle an
error argument, if it exists):

#+name:Mocha-asynchronous-test-done-directly
#+begin_src js -n
describe('User', function() {
  describe('#save()', function() {
    it('should save without error', function(done) {
      var user = new User('Luna');
      user.save(done);
    });
  });
});
#+end_src

{{{heading(Promises)}}}

Instead of using the ~done()~ callback, you may return a Promise.  This is
useful if the APIs you are testing return promises instead of taking callbacks:

#+name:Mocha-promises
#+begin_src js -n
beforeEach(function() {
  return db.clear().then(function() {
    return db.save([tobi, loki, jane]);
  });
});

describe('#find()', function() {
  it('respond with matching records', function() {
    return db.find({type: 'User'}).should.eventually.have.length(3);
  });
});
#+end_src

{{{heading(Async Await)}}}

If your JS environment supports =async / await=, you can also write
asynchronous tests like this:

#+begin_src js -n
beforeEach(async function() {
  await db.clear();
  await db.save([tobi, loki, jane]);
});

describe('#find()', function() {
  it('responds with matching records', async function() {
    const users = await db.find({type: 'User'});
    users.should.have.length(3);
  });
});
#+end_src

** Mocha and Testing Synchronous Code
When testing synchronous code, omit the callback and Mocha will automatically
continue on to the next test.

#+name:Mocha-synchronous-code
#+begin_src js -n
describe('Array', function() {
  describe('#indexOf()', function() {
    it('should return -1 when the value is not present', function() {
      [1, 2, 3].indexOf(5).should.equal(-1);
      [1, 2, 3].indexOf(0).should.equal(-1);
    });
  });
});
#+end_src

** Mocha Hooks
With its default “BDD”-style interface, Mocha provides the hooks:

- ~before()~

- ~after()~

- ~beforeEach()~

- ~afterEach()~


These should be used to set up preconditions and clean up after your tests:

#+name:Mocha-hooks
#+begin_src js -n
describe('hooks', function() {
  before(function() {
    // runs before all tests in this block
  });

  after(function() {
    // runs after all tests in this block
  });

  beforeEach(function() {
    // runs before each test in this block
  });

  afterEach(function() {
    // runs after each test in this block
  });

  // test cases
});
#+end_src

Tests can appear before, after, or interspersed with your hooks.  Hooks will
run in the order they are defined, as appropriate; all ~before()~ hooks run
(once), then any ~beforeEach()~ hooks, tests, any ~afterEach()~ hooks, and
finally ~after()~ hooks (once).

{{{heading(Describing Hooks)}}}

Any hook can be invoked with an optional description, making it easier to
pinpoint errors in your tests.  If a hook is given a named function, that name
will be used if no description is supplied.

#+name:Mocha-describe-hooks
#+begin_src js -n
beforeEach(function() {
  // beforeEach hook
});

beforeEach(function namedFun() {
  // beforeEach:namedFun
});

beforeEach('some description', function() {
  // beforeEach:some description
});
#+end_src

*** Asynchronous Hooks
All hooks (~before()~, ~after()~, ~beforeEach()~, ~afterEach()~) may be sync or
async as well, behaving much like a regular test-case.  For example, you may
wish to populate database with dummy content before each test:

#+name:Mocha-asynchronous-tests
#+begin_src js -n
describe('Connection', function() {
  var db = new Connection(),
    tobi = new User('tobi'),
    loki = new User('loki'),
    jane = new User('jane');

  beforeEach(function(done) {
    db.clear(function(err) {
      if (err) return done(err);
      db.save([tobi, loki, jane], done);
    });
  });

  describe('#find()', function() {
    it('respond with matching records', function(done) {
      db.find({type: 'User'}, function(err, res) {
        if (err) return done(err);
        res.should.have.length(3);
        done();
      });
    });
  });
});
#+end_src

*** Mocha Root Level Hooks
You may also pick any file and add “root”-level hooks.  For example, add
~beforeEach()~ outside of all ~describe()~ blocks.  This will cause the
callback to ~beforeEach()~ to run before any test case, regardless of the file
it lives in (this is because Mocha has an implied ~describe()~ block, called
the “root suite”).

#+name:Mocha-root-level-hook
#+begin_src js -n
beforeEach(function() {
  console.log('before every test in every file');
});
#+end_src

* Chai
- https://www.chaijs.com

* ESLint
“The pluggable linting utility for JavaScript and JSX”

- https://eslint.org


ESLint is an open source project originally created by Nicholas C. Zakas in
June 2013.  Its goal is to provide a pluggable linting utility for JavaScript.

** Get Started with ESLint
- https://eslint.org/docs/user-guide/getting-started


ESLint is a tool for identifying and reporting on patterns found in
ECMAScript/JavaScript code, with the goal of making code more consistent and
avoiding bugs.  In many ways, it is similar to JSLint and JSHint with a few
exceptions:

- ESLint uses [[https://github.com/eslint/espree][Espree]] for JavaScript parsing.

- ESLint uses an AST to evaluate patterns in code.

- ESLint is completely pluggable, every single rule is a plugin and you can add
  more at runtime.

* JSLint by David Crockford
“JSLint, The JavaScript Code Quality Tool”

“JSLint is a JavaScript program that looks for problems in JavaScript
programs.”

[[file:resources/hmmm.png]]

- https://www.jslint.com
- https://www.jslint.com/help.html
- https://github.com/douglascrockford/JSLint


JavaScript is a young-for-its-age language.  It was originally intended to do
small tasks in webpages, tasks for which Java was too heavy and clumsy.  But
JavaScript is a surprisingly capable language, and it is now being used in
larger projects.  Many of the features that were intended to make the language
easy to use are troublesome when projects become complicated.  A lint for
JavaScript is needed: JSLint, a JavaScript syntax checker and validator.

JSLint takes a JavaScript source and scans it.  If it finds a problem, it
returns a message describing the problem and an approximate location within the
source.  The problem is not necessarily a syntax error, although it often is.
JSLint looks at some style conventions as well as structural problems.  It does
not prove that your program is correct.  It just provides another set of eyes
to help spot problems.

JSLint defines a professional subset of JavaScript, a stricter language than
that defined by the ECMAScript Programming Language Standard (the strangely
named document that governs JavaScript).  JSLint will reject most legal
programs. It is a higher standard.

** JSLint and Style
The place to express yourself in programming is in the quality of your ideas and
the efficiency of their execution. The role of style in programming is the same
as in literature: It makes for better reading. A great writer doesn't express
herself by putting the spaces before her commas instead of after, or by putting
extra spaces inside her parentheses. A great writer will slavishly conform to
some rules of style, and that in no way constrains her power to express herself
creatively. See for example William Strunk's The Elements of Style.

This applies to programming as well. Conforming to a consistent style improves
readability, and frees you to express yourself in ways that matter. JSLint here
plays the part of a stern but benevolent editor, helping you to get the style
right so that you can focus your creative energy where it is most needed.

** JSLint and ES2015 Support
Some of ES6’s features are good, so JSLint will recognize the good parts of
ES6.

- The ... ellipsis marker in parameter lists and argument lists, replacing the
  arguments object for variadic functions.

- The let statement, which is like the var statement except that it respects
  block scope. You may use let or var but not both.

- The const statement is like the let statement except that it disallows the
  use of assignment on the variable, although if the value of the variable is
  mutable, it can still be mutated. const is preferred to let.

- Destructuring of arrays and objects is allowed in parameter lists and on the
  left side of let, and const, but not var or assignment statements, and not
  deep destructuring or eliding.

- Enhanced object literals, providing shorter forms for function declaration
  and properties that are initialized by variables with the same name.

- The fat arrow => fart functions.

- The simplest forms of import and export.

- `Megastring` literals, but not nested `megastring` literals.

- New global functions, such as Map, Set, WeakMap, and WeakSet.

- 0b- and 0o- number literals.


{{{heading(Tail Call Semants in ES2015)}}}

#+cindex:tail call
The most important new feature of ES6 is proper tail calls.  This has no new
syntax, so JSLint doesn’t see it.  But it makes recursion much more attractive,
which makes loops, particularly for loops, much less attractive.

{{{heading(Modules in ES2015)}}}

The ES6 module feature will be an important improvement over JavaScript’s
global variables as a means of linking separate files together.  JSLint
recognizes a small but essential subset of the module syntax.

#+begin_src js
import name from stringliteral;

import {name} from stringliteral;

export default function () {};

export default function name() {};

export default expression;

export function name() {}

export name; // where name is const

export {name};
#+end_src

** JSLint Directives

JSLint provides three directives that may be placed in a file to manage
JSLint’s behavior.  Use of these directives is optional.  If they are used,
they should be placed in a source file before the first statement.  They are
written in the form of a comment, where the directive name is placed
immediately after the opening of the comment before any whitespace.  The three
directives are =global=, =jslint=, and =property=.  Directives in a file are
stronger than options selected from the UI or passed with the option object.


* JSHint
“A Static Code Analysis Tool for JavaScript”

- https://jshint.com/about/
- https://jshint.com
- https://github.com/jshint/jshint


JSHint is a community-driven tool that detects errors and potential problems in
JavaScript code.  Since JSHint is so flexible, you can easily adjust it in the
environment you expect your code to execute.  JSHint is open source and will
always stay this way.

The project aims to help JavaScript developers write complex programs without
worrying about typos and language gotchas.  Any code base eventually becomes
huge at some point, so simple mistakes — that would not show themselves when
written — can become show stoppers and add extra hours of debugging.  So,
static code analysis tools come into play and help developers spot such
problems.  JSHint scans a program written in JavaScript and reports about
commonly made mistakes and potential bugs.  The potential problem could be a
syntax error, a bug due to an implicit type conversion, a leaking variable, or
something else entirely.

Only 15% of all programs linted on jshint.com pass the JSHint checks. In all
other cases, JSHint finds some red flags that could've been bugs or potential
problems.  Please note, that while static code analysis tools can spot many
different kind of mistakes, it can't detect if your program is correct, fast or
has memory leaks.  You should always combine tools like JSHint with unit and
functional tests as well as with code reviews.

** JSHint Installation
- https://jshint.com/install/


JSHint runs in a number of different environments; installation is different
for each.

{{{heading(Node.js installation)}}}

Each release of JSHint is published to npm, the package manager for the Node.js
platform.

{{{subheading(Install globally)}}}

You may install it globally using the following command:
: npm install -g jshint

After this, you can use the jshint command-line interface.

{{{subheading(Install locally as a development dependency)}}}

It is common to install JSHint as a development dependency within an existing
Node.js project:
: npm install --save-dev jshint

** JSHint Plugins for Text Editors
{{{heading(Emacs)}}}

- [[https://github.com/daleharvey/jshint-mode][jshint-mode]] :: JSHint mode for GNU Emacs.

- [[https://github.com/lunaryorn/flycheck][Flycheck]] :: on-the-fly syntax checking extension for GNU Emacs, built-in
     JSHint support.

- [[http://web-mode.org/][web-mode]] :: an autonomous major-mode for editing web templates supports
     JSHint.


{{{heading(Atom)}}}

- [[https://github.com/AtomLinter/linter-jshint][linter-jshint]] :: JSHint plugin for Atom's Linter.

- [[https://github.com/sindresorhus/atom-jshint][JSHint for Atom]] :: JSHint package for Atom.

** JSHint Documentation
- https://jshint.com/docs/

*** Basic Usage

*** Configuration

*** Command-Line Interface
The JSHint CLI can be installed via npm (see the Installation page for
instructions).

- https://jshint.com/docs/cli/

*** JSHint API
JSHint exposes a JavaScript API for programmatic access in environments like
web browsers and Node.js.

- https://jshint.com/docs/api/

* Concept Index
:PROPERTIES:
:unnumbered: t
:index:    cp
:END:
* Export Settings
#+options: H:4
* Macro Definitions                                                :noexport:
#+macro: heading @@texinfo:@heading@@ $1
#+macro: subheading @@texinfo:@subheading@@ $1
#+macro: command @@texinfo:@code{@@$1@@texinfo:}@@
#+macro: noindent @@texinfo:@noindent @@
#+macro: option @@texinfo:@option{@@$1@@texinfo:}@@
#+macro: var @@texinfo:@option{@@$1@@texinfo:}@@
#+macro: dfn @@texinfo:@dfn{@@$1@@texinfo:}@@

* Local Variables                                                  :noexport:
# Local Variables:
# fill-column:79
# time-stamp-pattern:"8/^\\#\\+date:%:y-%02m-%02d %02H:%02M$"
# eval: (org-indent-mode)
# eval: (electric-quote-local-mode)
# End:
